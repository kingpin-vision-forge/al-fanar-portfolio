"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/fraction.js";
exports.ids = ["vendor-chunks/fraction.js"];
exports.modules = {

/***/ "(ssr)/./node_modules/fraction.js/dist/fraction.mjs":
/*!****************************************************!*\
  !*** ./node_modules/fraction.js/dist/fraction.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Fraction: () => (/* binding */ Fraction),\n/* harmony export */   \"default\": () => (/* binding */ Fraction)\n/* harmony export */ });\n\n\n/**\n *\n * This class offers the possibility to calculate fractions.\n * You can pass a fraction in different formats. Either as array, as double, as string or as an integer.\n *\n * Array/Object form\n * [ 0 => <numerator>, 1 => <denominator> ]\n * { n => <numerator>, d => <denominator> }\n *\n * Integer form\n * - Single integer value as BigInt or Number\n *\n * Double form\n * - Single double value as Number\n *\n * String form\n * 123.456 - a simple double\n * 123/456 - a string fraction\n * 123.'456' - a double with repeating decimal places\n * 123.(456) - synonym\n * 123.45'6' - a double with repeating last place\n * 123.45(6) - synonym\n *\n * Example:\n * let f = new Fraction(\"9.4'31'\");\n * f.mul([-4, 3]).div(4.9);\n *\n */\n\n// Set Identity function to downgrade BigInt to Number if needed\nif (typeof BigInt === 'undefined') BigInt = function (n) { if (isNaN(n)) throw new Error(\"\"); return n; };\n\nconst C_ZERO = BigInt(0);\nconst C_ONE = BigInt(1);\nconst C_TWO = BigInt(2);\nconst C_THREE = BigInt(3);\nconst C_FIVE = BigInt(5);\nconst C_TEN = BigInt(10);\nconst MAX_INTEGER = BigInt(Number.MAX_SAFE_INTEGER);\n\n// Maximum search depth for cyclic rational numbers. 2000 should be more than enough.\n// Example: 1/7 = 0.(142857) has 6 repeating decimal places.\n// If MAX_CYCLE_LEN gets reduced, long cycles will not be detected and toString() only gets the first 10 digits\nconst MAX_CYCLE_LEN = 2000;\n\n// Parsed data to avoid calling \"new\" all the time\nconst P = {\n  \"s\": C_ONE,\n  \"n\": C_ZERO,\n  \"d\": C_ONE\n};\n\nfunction assign(n, s) {\n\n  try {\n    n = BigInt(n);\n  } catch (e) {\n    throw InvalidParameter();\n  }\n  return n * s;\n}\n\nfunction ifloor(x) {\n  return typeof x === 'bigint' ? x : Math.floor(x);\n}\n\n// Creates a new Fraction internally without the need of the bulky constructor\nfunction newFraction(n, d) {\n\n  if (d === C_ZERO) {\n    throw DivisionByZero();\n  }\n\n  const f = Object.create(Fraction.prototype);\n  f[\"s\"] = n < C_ZERO ? -C_ONE : C_ONE;\n\n  n = n < C_ZERO ? -n : n;\n\n  const a = gcd(n, d);\n\n  f[\"n\"] = n / a;\n  f[\"d\"] = d / a;\n  return f;\n}\n\nconst FACTORSTEPS = [C_TWO * C_TWO, C_TWO, C_TWO * C_TWO, C_TWO, C_TWO * C_TWO, C_TWO * C_THREE, C_TWO, C_TWO * C_THREE]; // repeats\nfunction factorize(n) {\n\n  const factors = Object.create(null);\n  if (n <= C_ONE) {\n    factors[n] = C_ONE;\n    return factors;\n  }\n\n  const add = (p) => { factors[p] = (factors[p] || C_ZERO) + C_ONE; };\n\n  while (n % C_TWO === C_ZERO) { add(C_TWO); n /= C_TWO; }\n  while (n % C_THREE === C_ZERO) { add(C_THREE); n /= C_THREE; }\n  while (n % C_FIVE === C_ZERO) { add(C_FIVE); n /= C_FIVE; }\n\n  // 30-wheel trial division: test only residues coprime to 2*3*5\n  // Residue step pattern after 5: 7,11,13,17,19,23,29,31, ...\n  for (let si = 0, p = C_TWO + C_FIVE; p * p <= n;) {\n    while (n % p === C_ZERO) { add(p); n /= p; }\n    p += FACTORSTEPS[si];\n    si = (si + 1) & 7; // fast modulo 8\n  }\n  if (n > C_ONE) add(n);\n  return factors;\n}\n\nconst parse = function (p1, p2) {\n\n  let n = C_ZERO, d = C_ONE, s = C_ONE;\n\n  if (p1 === undefined || p1 === null) { // No argument\n    /* void */\n  } else if (p2 !== undefined) { // Two arguments\n\n    if (typeof p1 === \"bigint\") {\n      n = p1;\n    } else if (isNaN(p1)) {\n      throw InvalidParameter();\n    } else if (p1 % 1 !== 0) {\n      throw NonIntegerParameter();\n    } else {\n      n = BigInt(p1);\n    }\n\n    if (typeof p2 === \"bigint\") {\n      d = p2;\n    } else if (isNaN(p2)) {\n      throw InvalidParameter();\n    } else if (p2 % 1 !== 0) {\n      throw NonIntegerParameter();\n    } else {\n      d = BigInt(p2);\n    }\n\n    s = n * d;\n\n  } else if (typeof p1 === \"object\") {\n    if (\"d\" in p1 && \"n\" in p1) {\n      n = BigInt(p1[\"n\"]);\n      d = BigInt(p1[\"d\"]);\n      if (\"s\" in p1)\n        n *= BigInt(p1[\"s\"]);\n    } else if (0 in p1) {\n      n = BigInt(p1[0]);\n      if (1 in p1)\n        d = BigInt(p1[1]);\n    } else if (typeof p1 === \"bigint\") {\n      n = p1;\n    } else {\n      throw InvalidParameter();\n    }\n    s = n * d;\n  } else if (typeof p1 === \"number\") {\n\n    if (isNaN(p1)) {\n      throw InvalidParameter();\n    }\n\n    if (p1 < 0) {\n      s = -C_ONE;\n      p1 = -p1;\n    }\n\n    if (p1 % 1 === 0) {\n      n = BigInt(p1);\n    } else {\n\n      let z = 1;\n\n      let A = 0, B = 1;\n      let C = 1, D = 1;\n\n      let N = 10000000;\n\n      if (p1 >= 1) {\n        z = 10 ** Math.floor(1 + Math.log10(p1));\n        p1 /= z;\n      }\n\n      // Using Farey Sequences\n\n      while (B <= N && D <= N) {\n        let M = (A + C) / (B + D);\n\n        if (p1 === M) {\n          if (B + D <= N) {\n            n = A + C;\n            d = B + D;\n          } else if (D > B) {\n            n = C;\n            d = D;\n          } else {\n            n = A;\n            d = B;\n          }\n          break;\n\n        } else {\n\n          if (p1 > M) {\n            A += C;\n            B += D;\n          } else {\n            C += A;\n            D += B;\n          }\n\n          if (B > N) {\n            n = C;\n            d = D;\n          } else {\n            n = A;\n            d = B;\n          }\n        }\n      }\n      n = BigInt(n) * BigInt(z);\n      d = BigInt(d);\n    }\n\n  } else if (typeof p1 === \"string\") {\n\n    let ndx = 0;\n\n    let v = C_ZERO, w = C_ZERO, x = C_ZERO, y = C_ONE, z = C_ONE;\n\n    let match = p1.replace(/_/g, '').match(/\\d+|./g);\n\n    if (match === null)\n      throw InvalidParameter();\n\n    if (match[ndx] === '-') {// Check for minus sign at the beginning\n      s = -C_ONE;\n      ndx++;\n    } else if (match[ndx] === '+') {// Check for plus sign at the beginning\n      ndx++;\n    }\n\n    if (match.length === ndx + 1) { // Check if it's just a simple number \"1234\"\n      w = assign(match[ndx++], s);\n    } else if (match[ndx + 1] === '.' || match[ndx] === '.') { // Check if it's a decimal number\n\n      if (match[ndx] !== '.') { // Handle 0.5 and .5\n        v = assign(match[ndx++], s);\n      }\n      ndx++;\n\n      // Check for decimal places\n      if (ndx + 1 === match.length || match[ndx + 1] === '(' && match[ndx + 3] === ')' || match[ndx + 1] === \"'\" && match[ndx + 3] === \"'\") {\n        w = assign(match[ndx], s);\n        y = C_TEN ** BigInt(match[ndx].length);\n        ndx++;\n      }\n\n      // Check for repeating places\n      if (match[ndx] === '(' && match[ndx + 2] === ')' || match[ndx] === \"'\" && match[ndx + 2] === \"'\") {\n        x = assign(match[ndx + 1], s);\n        z = C_TEN ** BigInt(match[ndx + 1].length) - C_ONE;\n        ndx += 3;\n      }\n\n    } else if (match[ndx + 1] === '/' || match[ndx + 1] === ':') { // Check for a simple fraction \"123/456\" or \"123:456\"\n      w = assign(match[ndx], s);\n      y = assign(match[ndx + 2], C_ONE);\n      ndx += 3;\n    } else if (match[ndx + 3] === '/' && match[ndx + 1] === ' ') { // Check for a complex fraction \"123 1/2\"\n      v = assign(match[ndx], s);\n      w = assign(match[ndx + 2], s);\n      y = assign(match[ndx + 4], C_ONE);\n      ndx += 5;\n    }\n\n    if (match.length <= ndx) { // Check for more tokens on the stack\n      d = y * z;\n      s = /* void */\n        n = x + d * v + z * w;\n    } else {\n      throw InvalidParameter();\n    }\n\n  } else if (typeof p1 === \"bigint\") {\n    n = p1;\n    s = p1;\n    d = C_ONE;\n  } else {\n    throw InvalidParameter();\n  }\n\n  if (d === C_ZERO) {\n    throw DivisionByZero();\n  }\n\n  P[\"s\"] = s < C_ZERO ? -C_ONE : C_ONE;\n  P[\"n\"] = n < C_ZERO ? -n : n;\n  P[\"d\"] = d < C_ZERO ? -d : d;\n};\n\nfunction modpow(b, e, m) {\n\n  let r = C_ONE;\n  for (; e > C_ZERO; b = (b * b) % m, e >>= C_ONE) {\n\n    if (e & C_ONE) {\n      r = (r * b) % m;\n    }\n  }\n  return r;\n}\n\nfunction cycleLen(n, d) {\n\n  for (; d % C_TWO === C_ZERO;\n    d /= C_TWO) {\n  }\n\n  for (; d % C_FIVE === C_ZERO;\n    d /= C_FIVE) {\n  }\n\n  if (d === C_ONE) // Catch non-cyclic numbers\n    return C_ZERO;\n\n  // If we would like to compute really large numbers quicker, we could make use of Fermat's little theorem:\n  // 10^(d-1) % d == 1\n  // However, we don't need such large numbers and MAX_CYCLE_LEN should be the capstone,\n  // as we want to translate the numbers to strings.\n\n  let rem = C_TEN % d;\n  let t = 1;\n\n  for (; rem !== C_ONE; t++) {\n    rem = rem * C_TEN % d;\n\n    if (t > MAX_CYCLE_LEN)\n      return C_ZERO; // Returning 0 here means that we don't print it as a cyclic number. It's likely that the answer is `d-1`\n  }\n  return BigInt(t);\n}\n\nfunction cycleStart(n, d, len) {\n\n  let rem1 = C_ONE;\n  let rem2 = modpow(C_TEN, len, d);\n\n  for (let t = 0; t < 300; t++) { // s < ~log10(Number.MAX_VALUE)\n    // Solve 10^s == 10^(s+t) (mod d)\n\n    if (rem1 === rem2)\n      return BigInt(t);\n\n    rem1 = rem1 * C_TEN % d;\n    rem2 = rem2 * C_TEN % d;\n  }\n  return 0;\n}\n\nfunction gcd(a, b) {\n\n  if (!a)\n    return b;\n  if (!b)\n    return a;\n\n  while (1) {\n    a %= b;\n    if (!a)\n      return b;\n    b %= a;\n    if (!b)\n      return a;\n  }\n}\n\n/**\n * Module constructor\n *\n * @constructor\n * @param {number|Fraction=} a\n * @param {number=} b\n */\nfunction Fraction(a, b) {\n\n  parse(a, b);\n\n  if (this instanceof Fraction) {\n    a = gcd(P[\"d\"], P[\"n\"]); // Abuse a\n    this[\"s\"] = P[\"s\"];\n    this[\"n\"] = P[\"n\"] / a;\n    this[\"d\"] = P[\"d\"] / a;\n  } else {\n    return newFraction(P['s'] * P['n'], P['d']);\n  }\n}\n\nconst DivisionByZero = function () { return new Error(\"Division by Zero\"); };\nconst InvalidParameter = function () { return new Error(\"Invalid argument\"); };\nconst NonIntegerParameter = function () { return new Error(\"Parameters must be integer\"); };\n\nFraction.prototype = {\n\n  \"s\": C_ONE,\n  \"n\": C_ZERO,\n  \"d\": C_ONE,\n\n  /**\n   * Calculates the absolute value\n   *\n   * Ex: new Fraction(-4).abs() => 4\n   **/\n  \"abs\": function () {\n\n    return newFraction(this[\"n\"], this[\"d\"]);\n  },\n\n  /**\n   * Inverts the sign of the current fraction\n   *\n   * Ex: new Fraction(-4).neg() => 4\n   **/\n  \"neg\": function () {\n\n    return newFraction(-this[\"s\"] * this[\"n\"], this[\"d\"]);\n  },\n\n  /**\n   * Adds two rational numbers\n   *\n   * Ex: new Fraction({n: 2, d: 3}).add(\"14.9\") => 467 / 30\n   **/\n  \"add\": function (a, b) {\n\n    parse(a, b);\n    return newFraction(\n      this[\"s\"] * this[\"n\"] * P[\"d\"] + P[\"s\"] * this[\"d\"] * P[\"n\"],\n      this[\"d\"] * P[\"d\"]\n    );\n  },\n\n  /**\n   * Subtracts two rational numbers\n   *\n   * Ex: new Fraction({n: 2, d: 3}).add(\"14.9\") => -427 / 30\n   **/\n  \"sub\": function (a, b) {\n\n    parse(a, b);\n    return newFraction(\n      this[\"s\"] * this[\"n\"] * P[\"d\"] - P[\"s\"] * this[\"d\"] * P[\"n\"],\n      this[\"d\"] * P[\"d\"]\n    );\n  },\n\n  /**\n   * Multiplies two rational numbers\n   *\n   * Ex: new Fraction(\"-17.(345)\").mul(3) => 5776 / 111\n   **/\n  \"mul\": function (a, b) {\n\n    parse(a, b);\n    return newFraction(\n      this[\"s\"] * P[\"s\"] * this[\"n\"] * P[\"n\"],\n      this[\"d\"] * P[\"d\"]\n    );\n  },\n\n  /**\n   * Divides two rational numbers\n   *\n   * Ex: new Fraction(\"-17.(345)\").inverse().div(3)\n   **/\n  \"div\": function (a, b) {\n\n    parse(a, b);\n    return newFraction(\n      this[\"s\"] * P[\"s\"] * this[\"n\"] * P[\"d\"],\n      this[\"d\"] * P[\"n\"]\n    );\n  },\n\n  /**\n   * Clones the actual object\n   *\n   * Ex: new Fraction(\"-17.(345)\").clone()\n   **/\n  \"clone\": function () {\n    return newFraction(this['s'] * this['n'], this['d']);\n  },\n\n  /**\n   * Calculates the modulo of two rational numbers - a more precise fmod\n   *\n   * Ex: new Fraction('4.(3)').mod([7, 8]) => (13/3) % (7/8) = (5/6)\n   * Ex: new Fraction(20, 10).mod().equals(0) ? \"is Integer\"\n   **/\n  \"mod\": function (a, b) {\n\n    if (a === undefined) {\n      return newFraction(this[\"s\"] * this[\"n\"] % this[\"d\"], C_ONE);\n    }\n\n    parse(a, b);\n    if (C_ZERO === P[\"n\"] * this[\"d\"]) {\n      throw DivisionByZero();\n    }\n\n    /**\n     * I derived the rational modulo similar to the modulo for integers\n     *\n     * https://raw.org/book/analysis/rational-numbers/\n     *\n     *    n1/d1 = (n2/d2) * q + r, where 0 ≤ r < n2/d2\n     * => d2 * n1 = n2 * d1 * q + d1 * d2 * r\n     * => r = (d2 * n1 - n2 * d1 * q) / (d1 * d2)\n     *      = (d2 * n1 - n2 * d1 * floor((d2 * n1) / (n2 * d1))) / (d1 * d2)\n     *      = ((d2 * n1) % (n2 * d1)) / (d1 * d2)\n     */\n    return newFraction(\n      this[\"s\"] * (P[\"d\"] * this[\"n\"]) % (P[\"n\"] * this[\"d\"]),\n      P[\"d\"] * this[\"d\"]);\n  },\n\n  /**\n   * Calculates the fractional gcd of two rational numbers\n   *\n   * Ex: new Fraction(5,8).gcd(3,7) => 1/56\n   */\n  \"gcd\": function (a, b) {\n\n    parse(a, b);\n\n    // https://raw.org/book/analysis/rational-numbers/\n    // gcd(a / b, c / d) = gcd(a, c) / lcm(b, d)\n\n    return newFraction(gcd(P[\"n\"], this[\"n\"]) * gcd(P[\"d\"], this[\"d\"]), P[\"d\"] * this[\"d\"]);\n  },\n\n  /**\n   * Calculates the fractional lcm of two rational numbers\n   *\n   * Ex: new Fraction(5,8).lcm(3,7) => 15\n   */\n  \"lcm\": function (a, b) {\n\n    parse(a, b);\n\n    // https://raw.org/book/analysis/rational-numbers/\n    // lcm(a / b, c / d) = lcm(a, c) / gcd(b, d)\n\n    if (P[\"n\"] === C_ZERO && this[\"n\"] === C_ZERO) {\n      return newFraction(C_ZERO, C_ONE);\n    }\n    return newFraction(P[\"n\"] * this[\"n\"], gcd(P[\"n\"], this[\"n\"]) * gcd(P[\"d\"], this[\"d\"]));\n  },\n\n  /**\n   * Gets the inverse of the fraction, means numerator and denominator are exchanged\n   *\n   * Ex: new Fraction([-3, 4]).inverse() => -4 / 3\n   **/\n  \"inverse\": function () {\n    return newFraction(this[\"s\"] * this[\"d\"], this[\"n\"]);\n  },\n\n  /**\n   * Calculates the fraction to some integer exponent\n   *\n   * Ex: new Fraction(-1,2).pow(-3) => -8\n   */\n  \"pow\": function (a, b) {\n\n    parse(a, b);\n\n    // Trivial case when exp is an integer\n\n    if (P['d'] === C_ONE) {\n\n      if (P['s'] < C_ZERO) {\n        return newFraction((this['s'] * this[\"d\"]) ** P['n'], this[\"n\"] ** P['n']);\n      } else {\n        return newFraction((this['s'] * this[\"n\"]) ** P['n'], this[\"d\"] ** P['n']);\n      }\n    }\n\n    // Negative roots become complex\n    //     (-a/b)^(c/d) = x\n    // ⇔ (-1)^(c/d) * (a/b)^(c/d) = x\n    // ⇔ (cos(pi) + i*sin(pi))^(c/d) * (a/b)^(c/d) = x\n    // ⇔ (cos(c*pi/d) + i*sin(c*pi/d)) * (a/b)^(c/d) = x       # DeMoivre's formula\n    // From which follows that only for c=0 the root is non-complex\n    if (this['s'] < C_ZERO) return null;\n\n    // Now prime factor n and d\n    let N = factorize(this['n']);\n    let D = factorize(this['d']);\n\n    // Exponentiate and take root for n and d individually\n    let n = C_ONE;\n    let d = C_ONE;\n    for (let k in N) {\n      if (k === '1') continue;\n      if (k === '0') {\n        n = C_ZERO;\n        break;\n      }\n      N[k] *= P['n'];\n\n      if (N[k] % P['d'] === C_ZERO) {\n        N[k] /= P['d'];\n      } else return null;\n      n *= BigInt(k) ** N[k];\n    }\n\n    for (let k in D) {\n      if (k === '1') continue;\n      D[k] *= P['n'];\n\n      if (D[k] % P['d'] === C_ZERO) {\n        D[k] /= P['d'];\n      } else return null;\n      d *= BigInt(k) ** D[k];\n    }\n\n    if (P['s'] < C_ZERO) {\n      return newFraction(d, n);\n    }\n    return newFraction(n, d);\n  },\n\n  /**\n   * Calculates the logarithm of a fraction to a given rational base\n   *\n   * Ex: new Fraction(27, 8).log(9, 4) => 3/2\n   */\n  \"log\": function (a, b) {\n\n    parse(a, b);\n\n    if (this['s'] <= C_ZERO || P['s'] <= C_ZERO) return null;\n\n    const allPrimes = Object.create(null);\n\n    const baseFactors = factorize(P['n']);\n    const T1 = factorize(P['d']);\n\n    const numberFactors = factorize(this['n']);\n    const T2 = factorize(this['d']);\n\n    for (const prime in T1) {\n      baseFactors[prime] = (baseFactors[prime] || C_ZERO) - T1[prime];\n    }\n    for (const prime in T2) {\n      numberFactors[prime] = (numberFactors[prime] || C_ZERO) - T2[prime];\n    }\n\n    for (const prime in baseFactors) {\n      if (prime === '1') continue;\n      allPrimes[prime] = true;\n    }\n    for (const prime in numberFactors) {\n      if (prime === '1') continue;\n      allPrimes[prime] = true;\n    }\n\n    let retN = null;\n    let retD = null;\n\n    // Iterate over all unique primes to determine if a consistent ratio exists\n    for (const prime in allPrimes) {\n\n      const baseExponent = baseFactors[prime] || C_ZERO;\n      const numberExponent = numberFactors[prime] || C_ZERO;\n\n      if (baseExponent === C_ZERO) {\n        if (numberExponent !== C_ZERO) {\n          return null; // Logarithm cannot be expressed as a rational number\n        }\n        continue; // Skip this prime since both exponents are zero\n      }\n\n      // Calculate the ratio of exponents for this prime\n      let curN = numberExponent;\n      let curD = baseExponent;\n\n      // Simplify the current ratio\n      const gcdValue = gcd(curN, curD);\n      curN /= gcdValue;\n      curD /= gcdValue;\n\n      // Check if this is the first ratio; otherwise, ensure ratios are consistent\n      if (retN === null && retD === null) {\n        retN = curN;\n        retD = curD;\n      } else if (curN * retD !== retN * curD) {\n        return null; // Ratios do not match, logarithm cannot be rational\n      }\n    }\n\n    return retN !== null && retD !== null\n      ? newFraction(retN, retD)\n      : null;\n  },\n\n  /**\n   * Check if two rational numbers are the same\n   *\n   * Ex: new Fraction(19.6).equals([98, 5]);\n   **/\n  \"equals\": function (a, b) {\n\n    parse(a, b);\n    return this[\"s\"] * this[\"n\"] * P[\"d\"] === P[\"s\"] * P[\"n\"] * this[\"d\"];\n  },\n\n  /**\n   * Check if this rational number is less than another\n   *\n   * Ex: new Fraction(19.6).lt([98, 5]);\n   **/\n  \"lt\": function (a, b) {\n\n    parse(a, b);\n    return this[\"s\"] * this[\"n\"] * P[\"d\"] < P[\"s\"] * P[\"n\"] * this[\"d\"];\n  },\n\n  /**\n   * Check if this rational number is less than or equal another\n   *\n   * Ex: new Fraction(19.6).lt([98, 5]);\n   **/\n  \"lte\": function (a, b) {\n\n    parse(a, b);\n    return this[\"s\"] * this[\"n\"] * P[\"d\"] <= P[\"s\"] * P[\"n\"] * this[\"d\"];\n  },\n\n  /**\n   * Check if this rational number is greater than another\n   *\n   * Ex: new Fraction(19.6).lt([98, 5]);\n   **/\n  \"gt\": function (a, b) {\n\n    parse(a, b);\n    return this[\"s\"] * this[\"n\"] * P[\"d\"] > P[\"s\"] * P[\"n\"] * this[\"d\"];\n  },\n\n  /**\n   * Check if this rational number is greater than or equal another\n   *\n   * Ex: new Fraction(19.6).lt([98, 5]);\n   **/\n  \"gte\": function (a, b) {\n\n    parse(a, b);\n    return this[\"s\"] * this[\"n\"] * P[\"d\"] >= P[\"s\"] * P[\"n\"] * this[\"d\"];\n  },\n\n  /**\n   * Compare two rational numbers\n   * < 0 iff this < that\n   * > 0 iff this > that\n   * = 0 iff this = that\n   *\n   * Ex: new Fraction(19.6).compare([98, 5]);\n   **/\n  \"compare\": function (a, b) {\n\n    parse(a, b);\n    let t = this[\"s\"] * this[\"n\"] * P[\"d\"] - P[\"s\"] * P[\"n\"] * this[\"d\"];\n\n    return (C_ZERO < t) - (t < C_ZERO);\n  },\n\n  /**\n   * Calculates the ceil of a rational number\n   *\n   * Ex: new Fraction('4.(3)').ceil() => (5 / 1)\n   **/\n  \"ceil\": function (places) {\n\n    places = C_TEN ** BigInt(places || 0);\n\n    return newFraction(ifloor(this[\"s\"] * places * this[\"n\"] / this[\"d\"]) +\n      (places * this[\"n\"] % this[\"d\"] > C_ZERO && this[\"s\"] >= C_ZERO ? C_ONE : C_ZERO),\n      places);\n  },\n\n  /**\n   * Calculates the floor of a rational number\n   *\n   * Ex: new Fraction('4.(3)').floor() => (4 / 1)\n   **/\n  \"floor\": function (places) {\n\n    places = C_TEN ** BigInt(places || 0);\n\n    return newFraction(ifloor(this[\"s\"] * places * this[\"n\"] / this[\"d\"]) -\n      (places * this[\"n\"] % this[\"d\"] > C_ZERO && this[\"s\"] < C_ZERO ? C_ONE : C_ZERO),\n      places);\n  },\n\n  /**\n   * Rounds a rational numbers\n   *\n   * Ex: new Fraction('4.(3)').round() => (4 / 1)\n   **/\n  \"round\": function (places) {\n\n    places = C_TEN ** BigInt(places || 0);\n\n    /* Derivation:\n\n    s >= 0:\n      round(n / d) = ifloor(n / d) + (n % d) / d >= 0.5 ? 1 : 0\n                   = ifloor(n / d) + 2(n % d) >= d ? 1 : 0\n    s < 0:\n      round(n / d) =-ifloor(n / d) - (n % d) / d > 0.5 ? 1 : 0\n                   =-ifloor(n / d) - 2(n % d) > d ? 1 : 0\n\n    =>:\n\n    round(s * n / d) = s * ifloor(n / d) + s * (C + 2(n % d) > d ? 1 : 0)\n        where C = s >= 0 ? 1 : 0, to fix the >= for the positve case.\n    */\n\n    return newFraction(ifloor(this[\"s\"] * places * this[\"n\"] / this[\"d\"]) +\n      this[\"s\"] * ((this[\"s\"] >= C_ZERO ? C_ONE : C_ZERO) + C_TWO * (places * this[\"n\"] % this[\"d\"]) > this[\"d\"] ? C_ONE : C_ZERO),\n      places);\n  },\n\n  /**\n    * Rounds a rational number to a multiple of another rational number\n    *\n    * Ex: new Fraction('0.9').roundTo(\"1/8\") => 7 / 8\n    **/\n  \"roundTo\": function (a, b) {\n\n    /*\n    k * x/y ≤ a/b < (k+1) * x/y\n    ⇔ k ≤ a/b / (x/y) < (k+1)\n    ⇔ k = floor(a/b * y/x)\n    ⇔ k = floor((a * y) / (b * x))\n    */\n\n    parse(a, b);\n\n    const n = this['n'] * P['d'];\n    const d = this['d'] * P['n'];\n    const r = n % d;\n\n    // round(n / d) = ifloor(n / d) + 2(n % d) >= d ? 1 : 0\n    let k = ifloor(n / d);\n    if (r + r >= d) {\n      k++;\n    }\n    return newFraction(this['s'] * k * P['n'], P['d']);\n  },\n\n  /**\n   * Check if two rational numbers are divisible\n   *\n   * Ex: new Fraction(19.6).divisible(1.5);\n   */\n  \"divisible\": function (a, b) {\n\n    parse(a, b);\n    if (P['n'] === C_ZERO) return false;\n    return (this['n'] * P['d']) % (P['n'] * this['d']) === C_ZERO;\n  },\n\n  /**\n   * Returns a decimal representation of the fraction\n   *\n   * Ex: new Fraction(\"100.'91823'\").valueOf() => 100.91823918239183\n   **/\n  'valueOf': function () {\n    //if (this['n'] <= MAX_INTEGER && this['d'] <= MAX_INTEGER) {\n    return Number(this['s'] * this['n']) / Number(this['d']);\n    //}\n  },\n\n  /**\n   * Creates a string representation of a fraction with all digits\n   *\n   * Ex: new Fraction(\"100.'91823'\").toString() => \"100.(91823)\"\n   **/\n  'toString': function (dec = 15) {\n\n    let N = this[\"n\"];\n    let D = this[\"d\"];\n\n    let cycLen = cycleLen(N, D); // Cycle length\n    let cycOff = cycleStart(N, D, cycLen); // Cycle start\n\n    let str = this['s'] < C_ZERO ? \"-\" : \"\";\n\n    // Append integer part\n    str += ifloor(N / D);\n\n    N %= D;\n    N *= C_TEN;\n\n    if (N)\n      str += \".\";\n\n    if (cycLen) {\n\n      for (let i = cycOff; i--;) {\n        str += ifloor(N / D);\n        N %= D;\n        N *= C_TEN;\n      }\n      str += \"(\";\n      for (let i = cycLen; i--;) {\n        str += ifloor(N / D);\n        N %= D;\n        N *= C_TEN;\n      }\n      str += \")\";\n    } else {\n      for (let i = dec; N && i--;) {\n        str += ifloor(N / D);\n        N %= D;\n        N *= C_TEN;\n      }\n    }\n    return str;\n  },\n\n  /**\n   * Returns a string-fraction representation of a Fraction object\n   *\n   * Ex: new Fraction(\"1.'3'\").toFraction() => \"4 1/3\"\n   **/\n  'toFraction': function (showMixed = false) {\n\n    let n = this[\"n\"];\n    let d = this[\"d\"];\n    let str = this['s'] < C_ZERO ? \"-\" : \"\";\n\n    if (d === C_ONE) {\n      str += n;\n    } else {\n      const whole = ifloor(n / d);\n      if (showMixed && whole > C_ZERO) {\n        str += whole;\n        str += \" \";\n        n %= d;\n      }\n\n      str += n;\n      str += '/';\n      str += d;\n    }\n    return str;\n  },\n\n  /**\n   * Returns a latex representation of a Fraction object\n   *\n   * Ex: new Fraction(\"1.'3'\").toLatex() => \"\\frac{4}{3}\"\n   **/\n  'toLatex': function (showMixed = false) {\n\n    let n = this[\"n\"];\n    let d = this[\"d\"];\n    let str = this['s'] < C_ZERO ? \"-\" : \"\";\n\n    if (d === C_ONE) {\n      str += n;\n    } else {\n      const whole = ifloor(n / d);\n      if (showMixed && whole > C_ZERO) {\n        str += whole;\n        n %= d;\n      }\n\n      str += \"\\\\frac{\";\n      str += n;\n      str += '}{';\n      str += d;\n      str += '}';\n    }\n    return str;\n  },\n\n  /**\n   * Returns an array of continued fraction elements\n   *\n   * Ex: new Fraction(\"7/8\").toContinued() => [0,1,7]\n   */\n  'toContinued': function () {\n\n    let a = this['n'];\n    let b = this['d'];\n    const res = [];\n\n    while (b) {\n      res.push(ifloor(a / b));\n      const t = a % b;\n      a = b;\n      b = t;\n    }\n    return res;\n  },\n\n  \"simplify\": function (eps = 1e-3) {\n\n    // Continued fractions give best approximations for a max denominator,\n    // generally outperforming mediants in denominator–accuracy trade-offs.\n    // Semiconvergents can further reduce the denominator within tolerance.\n\n    const ieps = BigInt(Math.ceil(1 / eps));\n\n    const thisABS = this['abs']();\n    const cont = thisABS['toContinued']();\n\n    for (let i = 1; i < cont.length; i++) {\n\n      let s = newFraction(cont[i - 1], C_ONE);\n      for (let k = i - 2; k >= 0; k--) {\n        s = s['inverse']()['add'](cont[k]);\n      }\n\n      let t = s['sub'](thisABS);\n      if (t['n'] * ieps < t['d']) { // More robust than Math.abs(t.valueOf()) < eps\n        return s['mul'](this['s']);\n      }\n    }\n    return this;\n  }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZnJhY3Rpb24uanMvZGlzdC9mcmFjdGlvbi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkRBQTJELG1DQUFtQzs7QUFFOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEhBQTBIO0FBQzFIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCOztBQUV2QixpQ0FBaUMsWUFBWTtBQUM3QyxtQ0FBbUMsY0FBYztBQUNqRCxrQ0FBa0MsYUFBYTs7QUFFL0M7QUFDQTtBQUNBLHVDQUF1QyxXQUFXO0FBQ2xELCtCQUErQixRQUFRO0FBQ3ZDO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHlDQUF5QztBQUN6QztBQUNBLElBQUksNkJBQTZCOztBQUVqQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsTUFBTSw4QkFBOEI7QUFDcEM7QUFDQTs7QUFFQSxvQ0FBb0M7QUFDcEM7QUFDQSxNQUFNLHlEQUF5RDs7QUFFL0QsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU0sNkRBQTZEO0FBQ25FO0FBQ0E7QUFDQTtBQUNBLE1BQU0sNkRBQTZEO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTLFlBQVk7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsU0FBUyxlQUFlO0FBQ3hCOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTLE9BQU87QUFDbEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDO0FBQ3JDLHVDQUF1QztBQUN2QywwQ0FBMEM7O0FBRTFDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsV0FBVztBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxrQkFBa0I7QUFDbEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQ0FBaUM7QUFDakMsMkNBQTJDOztBQUUzQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSwyQkFBMkIsSUFBSTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLElBQUk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTix3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELEdBQUcsRUFBRTtBQUN4RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7O0FBRXJDO0FBQ0EsMEJBQTBCLFFBQVE7QUFDbEM7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHRSIsInNvdXJjZXMiOlsiL1VzZXJzL25peWF6YWhhbWFkaGVya2FsL0RvY3VtZW50cy9wZXJzb25hbCB3b3JrL0FsZmFuYXIgUG9ydGZvbGlvL25vZGVfbW9kdWxlcy9mcmFjdGlvbi5qcy9kaXN0L2ZyYWN0aW9uLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICpcbiAqIFRoaXMgY2xhc3Mgb2ZmZXJzIHRoZSBwb3NzaWJpbGl0eSB0byBjYWxjdWxhdGUgZnJhY3Rpb25zLlxuICogWW91IGNhbiBwYXNzIGEgZnJhY3Rpb24gaW4gZGlmZmVyZW50IGZvcm1hdHMuIEVpdGhlciBhcyBhcnJheSwgYXMgZG91YmxlLCBhcyBzdHJpbmcgb3IgYXMgYW4gaW50ZWdlci5cbiAqXG4gKiBBcnJheS9PYmplY3QgZm9ybVxuICogWyAwID0+IDxudW1lcmF0b3I+LCAxID0+IDxkZW5vbWluYXRvcj4gXVxuICogeyBuID0+IDxudW1lcmF0b3I+LCBkID0+IDxkZW5vbWluYXRvcj4gfVxuICpcbiAqIEludGVnZXIgZm9ybVxuICogLSBTaW5nbGUgaW50ZWdlciB2YWx1ZSBhcyBCaWdJbnQgb3IgTnVtYmVyXG4gKlxuICogRG91YmxlIGZvcm1cbiAqIC0gU2luZ2xlIGRvdWJsZSB2YWx1ZSBhcyBOdW1iZXJcbiAqXG4gKiBTdHJpbmcgZm9ybVxuICogMTIzLjQ1NiAtIGEgc2ltcGxlIGRvdWJsZVxuICogMTIzLzQ1NiAtIGEgc3RyaW5nIGZyYWN0aW9uXG4gKiAxMjMuJzQ1NicgLSBhIGRvdWJsZSB3aXRoIHJlcGVhdGluZyBkZWNpbWFsIHBsYWNlc1xuICogMTIzLig0NTYpIC0gc3lub255bVxuICogMTIzLjQ1JzYnIC0gYSBkb3VibGUgd2l0aCByZXBlYXRpbmcgbGFzdCBwbGFjZVxuICogMTIzLjQ1KDYpIC0gc3lub255bVxuICpcbiAqIEV4YW1wbGU6XG4gKiBsZXQgZiA9IG5ldyBGcmFjdGlvbihcIjkuNCczMSdcIik7XG4gKiBmLm11bChbLTQsIDNdKS5kaXYoNC45KTtcbiAqXG4gKi9cblxuLy8gU2V0IElkZW50aXR5IGZ1bmN0aW9uIHRvIGRvd25ncmFkZSBCaWdJbnQgdG8gTnVtYmVyIGlmIG5lZWRlZFxuaWYgKHR5cGVvZiBCaWdJbnQgPT09ICd1bmRlZmluZWQnKSBCaWdJbnQgPSBmdW5jdGlvbiAobikgeyBpZiAoaXNOYU4obikpIHRocm93IG5ldyBFcnJvcihcIlwiKTsgcmV0dXJuIG47IH07XG5cbmNvbnN0IENfWkVSTyA9IEJpZ0ludCgwKTtcbmNvbnN0IENfT05FID0gQmlnSW50KDEpO1xuY29uc3QgQ19UV08gPSBCaWdJbnQoMik7XG5jb25zdCBDX1RIUkVFID0gQmlnSW50KDMpO1xuY29uc3QgQ19GSVZFID0gQmlnSW50KDUpO1xuY29uc3QgQ19URU4gPSBCaWdJbnQoMTApO1xuY29uc3QgTUFYX0lOVEVHRVIgPSBCaWdJbnQoTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpO1xuXG4vLyBNYXhpbXVtIHNlYXJjaCBkZXB0aCBmb3IgY3ljbGljIHJhdGlvbmFsIG51bWJlcnMuIDIwMDAgc2hvdWxkIGJlIG1vcmUgdGhhbiBlbm91Z2guXG4vLyBFeGFtcGxlOiAxLzcgPSAwLigxNDI4NTcpIGhhcyA2IHJlcGVhdGluZyBkZWNpbWFsIHBsYWNlcy5cbi8vIElmIE1BWF9DWUNMRV9MRU4gZ2V0cyByZWR1Y2VkLCBsb25nIGN5Y2xlcyB3aWxsIG5vdCBiZSBkZXRlY3RlZCBhbmQgdG9TdHJpbmcoKSBvbmx5IGdldHMgdGhlIGZpcnN0IDEwIGRpZ2l0c1xuY29uc3QgTUFYX0NZQ0xFX0xFTiA9IDIwMDA7XG5cbi8vIFBhcnNlZCBkYXRhIHRvIGF2b2lkIGNhbGxpbmcgXCJuZXdcIiBhbGwgdGhlIHRpbWVcbmNvbnN0IFAgPSB7XG4gIFwic1wiOiBDX09ORSxcbiAgXCJuXCI6IENfWkVSTyxcbiAgXCJkXCI6IENfT05FXG59O1xuXG5mdW5jdGlvbiBhc3NpZ24obiwgcykge1xuXG4gIHRyeSB7XG4gICAgbiA9IEJpZ0ludChuKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IEludmFsaWRQYXJhbWV0ZXIoKTtcbiAgfVxuICByZXR1cm4gbiAqIHM7XG59XG5cbmZ1bmN0aW9uIGlmbG9vcih4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gJ2JpZ2ludCcgPyB4IDogTWF0aC5mbG9vcih4KTtcbn1cblxuLy8gQ3JlYXRlcyBhIG5ldyBGcmFjdGlvbiBpbnRlcm5hbGx5IHdpdGhvdXQgdGhlIG5lZWQgb2YgdGhlIGJ1bGt5IGNvbnN0cnVjdG9yXG5mdW5jdGlvbiBuZXdGcmFjdGlvbihuLCBkKSB7XG5cbiAgaWYgKGQgPT09IENfWkVSTykge1xuICAgIHRocm93IERpdmlzaW9uQnlaZXJvKCk7XG4gIH1cblxuICBjb25zdCBmID0gT2JqZWN0LmNyZWF0ZShGcmFjdGlvbi5wcm90b3R5cGUpO1xuICBmW1wic1wiXSA9IG4gPCBDX1pFUk8gPyAtQ19PTkUgOiBDX09ORTtcblxuICBuID0gbiA8IENfWkVSTyA/IC1uIDogbjtcblxuICBjb25zdCBhID0gZ2NkKG4sIGQpO1xuXG4gIGZbXCJuXCJdID0gbiAvIGE7XG4gIGZbXCJkXCJdID0gZCAvIGE7XG4gIHJldHVybiBmO1xufVxuXG5jb25zdCBGQUNUT1JTVEVQUyA9IFtDX1RXTyAqIENfVFdPLCBDX1RXTywgQ19UV08gKiBDX1RXTywgQ19UV08sIENfVFdPICogQ19UV08sIENfVFdPICogQ19USFJFRSwgQ19UV08sIENfVFdPICogQ19USFJFRV07IC8vIHJlcGVhdHNcbmZ1bmN0aW9uIGZhY3Rvcml6ZShuKSB7XG5cbiAgY29uc3QgZmFjdG9ycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGlmIChuIDw9IENfT05FKSB7XG4gICAgZmFjdG9yc1tuXSA9IENfT05FO1xuICAgIHJldHVybiBmYWN0b3JzO1xuICB9XG5cbiAgY29uc3QgYWRkID0gKHApID0+IHsgZmFjdG9yc1twXSA9IChmYWN0b3JzW3BdIHx8IENfWkVSTykgKyBDX09ORTsgfTtcblxuICB3aGlsZSAobiAlIENfVFdPID09PSBDX1pFUk8pIHsgYWRkKENfVFdPKTsgbiAvPSBDX1RXTzsgfVxuICB3aGlsZSAobiAlIENfVEhSRUUgPT09IENfWkVSTykgeyBhZGQoQ19USFJFRSk7IG4gLz0gQ19USFJFRTsgfVxuICB3aGlsZSAobiAlIENfRklWRSA9PT0gQ19aRVJPKSB7IGFkZChDX0ZJVkUpOyBuIC89IENfRklWRTsgfVxuXG4gIC8vIDMwLXdoZWVsIHRyaWFsIGRpdmlzaW9uOiB0ZXN0IG9ubHkgcmVzaWR1ZXMgY29wcmltZSB0byAyKjMqNVxuICAvLyBSZXNpZHVlIHN0ZXAgcGF0dGVybiBhZnRlciA1OiA3LDExLDEzLDE3LDE5LDIzLDI5LDMxLCAuLi5cbiAgZm9yIChsZXQgc2kgPSAwLCBwID0gQ19UV08gKyBDX0ZJVkU7IHAgKiBwIDw9IG47KSB7XG4gICAgd2hpbGUgKG4gJSBwID09PSBDX1pFUk8pIHsgYWRkKHApOyBuIC89IHA7IH1cbiAgICBwICs9IEZBQ1RPUlNURVBTW3NpXTtcbiAgICBzaSA9IChzaSArIDEpICYgNzsgLy8gZmFzdCBtb2R1bG8gOFxuICB9XG4gIGlmIChuID4gQ19PTkUpIGFkZChuKTtcbiAgcmV0dXJuIGZhY3RvcnM7XG59XG5cbmNvbnN0IHBhcnNlID0gZnVuY3Rpb24gKHAxLCBwMikge1xuXG4gIGxldCBuID0gQ19aRVJPLCBkID0gQ19PTkUsIHMgPSBDX09ORTtcblxuICBpZiAocDEgPT09IHVuZGVmaW5lZCB8fCBwMSA9PT0gbnVsbCkgeyAvLyBObyBhcmd1bWVudFxuICAgIC8qIHZvaWQgKi9cbiAgfSBlbHNlIGlmIChwMiAhPT0gdW5kZWZpbmVkKSB7IC8vIFR3byBhcmd1bWVudHNcblxuICAgIGlmICh0eXBlb2YgcDEgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgIG4gPSBwMTtcbiAgICB9IGVsc2UgaWYgKGlzTmFOKHAxKSkge1xuICAgICAgdGhyb3cgSW52YWxpZFBhcmFtZXRlcigpO1xuICAgIH0gZWxzZSBpZiAocDEgJSAxICE9PSAwKSB7XG4gICAgICB0aHJvdyBOb25JbnRlZ2VyUGFyYW1ldGVyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG4gPSBCaWdJbnQocDEpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcDIgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgIGQgPSBwMjtcbiAgICB9IGVsc2UgaWYgKGlzTmFOKHAyKSkge1xuICAgICAgdGhyb3cgSW52YWxpZFBhcmFtZXRlcigpO1xuICAgIH0gZWxzZSBpZiAocDIgJSAxICE9PSAwKSB7XG4gICAgICB0aHJvdyBOb25JbnRlZ2VyUGFyYW1ldGVyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGQgPSBCaWdJbnQocDIpO1xuICAgIH1cblxuICAgIHMgPSBuICogZDtcblxuICB9IGVsc2UgaWYgKHR5cGVvZiBwMSA9PT0gXCJvYmplY3RcIikge1xuICAgIGlmIChcImRcIiBpbiBwMSAmJiBcIm5cIiBpbiBwMSkge1xuICAgICAgbiA9IEJpZ0ludChwMVtcIm5cIl0pO1xuICAgICAgZCA9IEJpZ0ludChwMVtcImRcIl0pO1xuICAgICAgaWYgKFwic1wiIGluIHAxKVxuICAgICAgICBuICo9IEJpZ0ludChwMVtcInNcIl0pO1xuICAgIH0gZWxzZSBpZiAoMCBpbiBwMSkge1xuICAgICAgbiA9IEJpZ0ludChwMVswXSk7XG4gICAgICBpZiAoMSBpbiBwMSlcbiAgICAgICAgZCA9IEJpZ0ludChwMVsxXSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcDEgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgIG4gPSBwMTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgSW52YWxpZFBhcmFtZXRlcigpO1xuICAgIH1cbiAgICBzID0gbiAqIGQ7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHAxID09PSBcIm51bWJlclwiKSB7XG5cbiAgICBpZiAoaXNOYU4ocDEpKSB7XG4gICAgICB0aHJvdyBJbnZhbGlkUGFyYW1ldGVyKCk7XG4gICAgfVxuXG4gICAgaWYgKHAxIDwgMCkge1xuICAgICAgcyA9IC1DX09ORTtcbiAgICAgIHAxID0gLXAxO1xuICAgIH1cblxuICAgIGlmIChwMSAlIDEgPT09IDApIHtcbiAgICAgIG4gPSBCaWdJbnQocDEpO1xuICAgIH0gZWxzZSB7XG5cbiAgICAgIGxldCB6ID0gMTtcblxuICAgICAgbGV0IEEgPSAwLCBCID0gMTtcbiAgICAgIGxldCBDID0gMSwgRCA9IDE7XG5cbiAgICAgIGxldCBOID0gMTAwMDAwMDA7XG5cbiAgICAgIGlmIChwMSA+PSAxKSB7XG4gICAgICAgIHogPSAxMCAqKiBNYXRoLmZsb29yKDEgKyBNYXRoLmxvZzEwKHAxKSk7XG4gICAgICAgIHAxIC89IHo7XG4gICAgICB9XG5cbiAgICAgIC8vIFVzaW5nIEZhcmV5IFNlcXVlbmNlc1xuXG4gICAgICB3aGlsZSAoQiA8PSBOICYmIEQgPD0gTikge1xuICAgICAgICBsZXQgTSA9IChBICsgQykgLyAoQiArIEQpO1xuXG4gICAgICAgIGlmIChwMSA9PT0gTSkge1xuICAgICAgICAgIGlmIChCICsgRCA8PSBOKSB7XG4gICAgICAgICAgICBuID0gQSArIEM7XG4gICAgICAgICAgICBkID0gQiArIEQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChEID4gQikge1xuICAgICAgICAgICAgbiA9IEM7XG4gICAgICAgICAgICBkID0gRDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbiA9IEE7XG4gICAgICAgICAgICBkID0gQjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIGlmIChwMSA+IE0pIHtcbiAgICAgICAgICAgIEEgKz0gQztcbiAgICAgICAgICAgIEIgKz0gRDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgQyArPSBBO1xuICAgICAgICAgICAgRCArPSBCO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChCID4gTikge1xuICAgICAgICAgICAgbiA9IEM7XG4gICAgICAgICAgICBkID0gRDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbiA9IEE7XG4gICAgICAgICAgICBkID0gQjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG4gPSBCaWdJbnQobikgKiBCaWdJbnQoeik7XG4gICAgICBkID0gQmlnSW50KGQpO1xuICAgIH1cblxuICB9IGVsc2UgaWYgKHR5cGVvZiBwMSA9PT0gXCJzdHJpbmdcIikge1xuXG4gICAgbGV0IG5keCA9IDA7XG5cbiAgICBsZXQgdiA9IENfWkVSTywgdyA9IENfWkVSTywgeCA9IENfWkVSTywgeSA9IENfT05FLCB6ID0gQ19PTkU7XG5cbiAgICBsZXQgbWF0Y2ggPSBwMS5yZXBsYWNlKC9fL2csICcnKS5tYXRjaCgvXFxkK3wuL2cpO1xuXG4gICAgaWYgKG1hdGNoID09PSBudWxsKVxuICAgICAgdGhyb3cgSW52YWxpZFBhcmFtZXRlcigpO1xuXG4gICAgaWYgKG1hdGNoW25keF0gPT09ICctJykgey8vIENoZWNrIGZvciBtaW51cyBzaWduIGF0IHRoZSBiZWdpbm5pbmdcbiAgICAgIHMgPSAtQ19PTkU7XG4gICAgICBuZHgrKztcbiAgICB9IGVsc2UgaWYgKG1hdGNoW25keF0gPT09ICcrJykgey8vIENoZWNrIGZvciBwbHVzIHNpZ24gYXQgdGhlIGJlZ2lubmluZ1xuICAgICAgbmR4Kys7XG4gICAgfVxuXG4gICAgaWYgKG1hdGNoLmxlbmd0aCA9PT0gbmR4ICsgMSkgeyAvLyBDaGVjayBpZiBpdCdzIGp1c3QgYSBzaW1wbGUgbnVtYmVyIFwiMTIzNFwiXG4gICAgICB3ID0gYXNzaWduKG1hdGNoW25keCsrXSwgcyk7XG4gICAgfSBlbHNlIGlmIChtYXRjaFtuZHggKyAxXSA9PT0gJy4nIHx8IG1hdGNoW25keF0gPT09ICcuJykgeyAvLyBDaGVjayBpZiBpdCdzIGEgZGVjaW1hbCBudW1iZXJcblxuICAgICAgaWYgKG1hdGNoW25keF0gIT09ICcuJykgeyAvLyBIYW5kbGUgMC41IGFuZCAuNVxuICAgICAgICB2ID0gYXNzaWduKG1hdGNoW25keCsrXSwgcyk7XG4gICAgICB9XG4gICAgICBuZHgrKztcblxuICAgICAgLy8gQ2hlY2sgZm9yIGRlY2ltYWwgcGxhY2VzXG4gICAgICBpZiAobmR4ICsgMSA9PT0gbWF0Y2gubGVuZ3RoIHx8IG1hdGNoW25keCArIDFdID09PSAnKCcgJiYgbWF0Y2hbbmR4ICsgM10gPT09ICcpJyB8fCBtYXRjaFtuZHggKyAxXSA9PT0gXCInXCIgJiYgbWF0Y2hbbmR4ICsgM10gPT09IFwiJ1wiKSB7XG4gICAgICAgIHcgPSBhc3NpZ24obWF0Y2hbbmR4XSwgcyk7XG4gICAgICAgIHkgPSBDX1RFTiAqKiBCaWdJbnQobWF0Y2hbbmR4XS5sZW5ndGgpO1xuICAgICAgICBuZHgrKztcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgZm9yIHJlcGVhdGluZyBwbGFjZXNcbiAgICAgIGlmIChtYXRjaFtuZHhdID09PSAnKCcgJiYgbWF0Y2hbbmR4ICsgMl0gPT09ICcpJyB8fCBtYXRjaFtuZHhdID09PSBcIidcIiAmJiBtYXRjaFtuZHggKyAyXSA9PT0gXCInXCIpIHtcbiAgICAgICAgeCA9IGFzc2lnbihtYXRjaFtuZHggKyAxXSwgcyk7XG4gICAgICAgIHogPSBDX1RFTiAqKiBCaWdJbnQobWF0Y2hbbmR4ICsgMV0ubGVuZ3RoKSAtIENfT05FO1xuICAgICAgICBuZHggKz0gMztcbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAobWF0Y2hbbmR4ICsgMV0gPT09ICcvJyB8fCBtYXRjaFtuZHggKyAxXSA9PT0gJzonKSB7IC8vIENoZWNrIGZvciBhIHNpbXBsZSBmcmFjdGlvbiBcIjEyMy80NTZcIiBvciBcIjEyMzo0NTZcIlxuICAgICAgdyA9IGFzc2lnbihtYXRjaFtuZHhdLCBzKTtcbiAgICAgIHkgPSBhc3NpZ24obWF0Y2hbbmR4ICsgMl0sIENfT05FKTtcbiAgICAgIG5keCArPSAzO1xuICAgIH0gZWxzZSBpZiAobWF0Y2hbbmR4ICsgM10gPT09ICcvJyAmJiBtYXRjaFtuZHggKyAxXSA9PT0gJyAnKSB7IC8vIENoZWNrIGZvciBhIGNvbXBsZXggZnJhY3Rpb24gXCIxMjMgMS8yXCJcbiAgICAgIHYgPSBhc3NpZ24obWF0Y2hbbmR4XSwgcyk7XG4gICAgICB3ID0gYXNzaWduKG1hdGNoW25keCArIDJdLCBzKTtcbiAgICAgIHkgPSBhc3NpZ24obWF0Y2hbbmR4ICsgNF0sIENfT05FKTtcbiAgICAgIG5keCArPSA1O1xuICAgIH1cblxuICAgIGlmIChtYXRjaC5sZW5ndGggPD0gbmR4KSB7IC8vIENoZWNrIGZvciBtb3JlIHRva2VucyBvbiB0aGUgc3RhY2tcbiAgICAgIGQgPSB5ICogejtcbiAgICAgIHMgPSAvKiB2b2lkICovXG4gICAgICAgIG4gPSB4ICsgZCAqIHYgKyB6ICogdztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgSW52YWxpZFBhcmFtZXRlcigpO1xuICAgIH1cblxuICB9IGVsc2UgaWYgKHR5cGVvZiBwMSA9PT0gXCJiaWdpbnRcIikge1xuICAgIG4gPSBwMTtcbiAgICBzID0gcDE7XG4gICAgZCA9IENfT05FO1xuICB9IGVsc2Uge1xuICAgIHRocm93IEludmFsaWRQYXJhbWV0ZXIoKTtcbiAgfVxuXG4gIGlmIChkID09PSBDX1pFUk8pIHtcbiAgICB0aHJvdyBEaXZpc2lvbkJ5WmVybygpO1xuICB9XG5cbiAgUFtcInNcIl0gPSBzIDwgQ19aRVJPID8gLUNfT05FIDogQ19PTkU7XG4gIFBbXCJuXCJdID0gbiA8IENfWkVSTyA/IC1uIDogbjtcbiAgUFtcImRcIl0gPSBkIDwgQ19aRVJPID8gLWQgOiBkO1xufTtcblxuZnVuY3Rpb24gbW9kcG93KGIsIGUsIG0pIHtcblxuICBsZXQgciA9IENfT05FO1xuICBmb3IgKDsgZSA+IENfWkVSTzsgYiA9IChiICogYikgJSBtLCBlID4+PSBDX09ORSkge1xuXG4gICAgaWYgKGUgJiBDX09ORSkge1xuICAgICAgciA9IChyICogYikgJSBtO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gY3ljbGVMZW4obiwgZCkge1xuXG4gIGZvciAoOyBkICUgQ19UV08gPT09IENfWkVSTztcbiAgICBkIC89IENfVFdPKSB7XG4gIH1cblxuICBmb3IgKDsgZCAlIENfRklWRSA9PT0gQ19aRVJPO1xuICAgIGQgLz0gQ19GSVZFKSB7XG4gIH1cblxuICBpZiAoZCA9PT0gQ19PTkUpIC8vIENhdGNoIG5vbi1jeWNsaWMgbnVtYmVyc1xuICAgIHJldHVybiBDX1pFUk87XG5cbiAgLy8gSWYgd2Ugd291bGQgbGlrZSB0byBjb21wdXRlIHJlYWxseSBsYXJnZSBudW1iZXJzIHF1aWNrZXIsIHdlIGNvdWxkIG1ha2UgdXNlIG9mIEZlcm1hdCdzIGxpdHRsZSB0aGVvcmVtOlxuICAvLyAxMF4oZC0xKSAlIGQgPT0gMVxuICAvLyBIb3dldmVyLCB3ZSBkb24ndCBuZWVkIHN1Y2ggbGFyZ2UgbnVtYmVycyBhbmQgTUFYX0NZQ0xFX0xFTiBzaG91bGQgYmUgdGhlIGNhcHN0b25lLFxuICAvLyBhcyB3ZSB3YW50IHRvIHRyYW5zbGF0ZSB0aGUgbnVtYmVycyB0byBzdHJpbmdzLlxuXG4gIGxldCByZW0gPSBDX1RFTiAlIGQ7XG4gIGxldCB0ID0gMTtcblxuICBmb3IgKDsgcmVtICE9PSBDX09ORTsgdCsrKSB7XG4gICAgcmVtID0gcmVtICogQ19URU4gJSBkO1xuXG4gICAgaWYgKHQgPiBNQVhfQ1lDTEVfTEVOKVxuICAgICAgcmV0dXJuIENfWkVSTzsgLy8gUmV0dXJuaW5nIDAgaGVyZSBtZWFucyB0aGF0IHdlIGRvbid0IHByaW50IGl0IGFzIGEgY3ljbGljIG51bWJlci4gSXQncyBsaWtlbHkgdGhhdCB0aGUgYW5zd2VyIGlzIGBkLTFgXG4gIH1cbiAgcmV0dXJuIEJpZ0ludCh0KTtcbn1cblxuZnVuY3Rpb24gY3ljbGVTdGFydChuLCBkLCBsZW4pIHtcblxuICBsZXQgcmVtMSA9IENfT05FO1xuICBsZXQgcmVtMiA9IG1vZHBvdyhDX1RFTiwgbGVuLCBkKTtcblxuICBmb3IgKGxldCB0ID0gMDsgdCA8IDMwMDsgdCsrKSB7IC8vIHMgPCB+bG9nMTAoTnVtYmVyLk1BWF9WQUxVRSlcbiAgICAvLyBTb2x2ZSAxMF5zID09IDEwXihzK3QpIChtb2QgZClcblxuICAgIGlmIChyZW0xID09PSByZW0yKVxuICAgICAgcmV0dXJuIEJpZ0ludCh0KTtcblxuICAgIHJlbTEgPSByZW0xICogQ19URU4gJSBkO1xuICAgIHJlbTIgPSByZW0yICogQ19URU4gJSBkO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBnY2QoYSwgYikge1xuXG4gIGlmICghYSlcbiAgICByZXR1cm4gYjtcbiAgaWYgKCFiKVxuICAgIHJldHVybiBhO1xuXG4gIHdoaWxlICgxKSB7XG4gICAgYSAlPSBiO1xuICAgIGlmICghYSlcbiAgICAgIHJldHVybiBiO1xuICAgIGIgJT0gYTtcbiAgICBpZiAoIWIpXG4gICAgICByZXR1cm4gYTtcbiAgfVxufVxuXG4vKipcbiAqIE1vZHVsZSBjb25zdHJ1Y3RvclxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtudW1iZXJ8RnJhY3Rpb249fSBhXG4gKiBAcGFyYW0ge251bWJlcj19IGJcbiAqL1xuZnVuY3Rpb24gRnJhY3Rpb24oYSwgYikge1xuXG4gIHBhcnNlKGEsIGIpO1xuXG4gIGlmICh0aGlzIGluc3RhbmNlb2YgRnJhY3Rpb24pIHtcbiAgICBhID0gZ2NkKFBbXCJkXCJdLCBQW1wiblwiXSk7IC8vIEFidXNlIGFcbiAgICB0aGlzW1wic1wiXSA9IFBbXCJzXCJdO1xuICAgIHRoaXNbXCJuXCJdID0gUFtcIm5cIl0gLyBhO1xuICAgIHRoaXNbXCJkXCJdID0gUFtcImRcIl0gLyBhO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXdGcmFjdGlvbihQWydzJ10gKiBQWyduJ10sIFBbJ2QnXSk7XG4gIH1cbn1cblxuY29uc3QgRGl2aXNpb25CeVplcm8gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgRXJyb3IoXCJEaXZpc2lvbiBieSBaZXJvXCIpOyB9O1xuY29uc3QgSW52YWxpZFBhcmFtZXRlciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBFcnJvcihcIkludmFsaWQgYXJndW1lbnRcIik7IH07XG5jb25zdCBOb25JbnRlZ2VyUGFyYW1ldGVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEVycm9yKFwiUGFyYW1ldGVycyBtdXN0IGJlIGludGVnZXJcIik7IH07XG5cbkZyYWN0aW9uLnByb3RvdHlwZSA9IHtcblxuICBcInNcIjogQ19PTkUsXG4gIFwiblwiOiBDX1pFUk8sXG4gIFwiZFwiOiBDX09ORSxcblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgYWJzb2x1dGUgdmFsdWVcbiAgICpcbiAgICogRXg6IG5ldyBGcmFjdGlvbigtNCkuYWJzKCkgPT4gNFxuICAgKiovXG4gIFwiYWJzXCI6IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiBuZXdGcmFjdGlvbih0aGlzW1wiblwiXSwgdGhpc1tcImRcIl0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbnZlcnRzIHRoZSBzaWduIG9mIHRoZSBjdXJyZW50IGZyYWN0aW9uXG4gICAqXG4gICAqIEV4OiBuZXcgRnJhY3Rpb24oLTQpLm5lZygpID0+IDRcbiAgICoqL1xuICBcIm5lZ1wiOiBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gbmV3RnJhY3Rpb24oLXRoaXNbXCJzXCJdICogdGhpc1tcIm5cIl0sIHRoaXNbXCJkXCJdKTtcbiAgfSxcblxuICAvKipcbiAgICogQWRkcyB0d28gcmF0aW9uYWwgbnVtYmVyc1xuICAgKlxuICAgKiBFeDogbmV3IEZyYWN0aW9uKHtuOiAyLCBkOiAzfSkuYWRkKFwiMTQuOVwiKSA9PiA0NjcgLyAzMFxuICAgKiovXG4gIFwiYWRkXCI6IGZ1bmN0aW9uIChhLCBiKSB7XG5cbiAgICBwYXJzZShhLCBiKTtcbiAgICByZXR1cm4gbmV3RnJhY3Rpb24oXG4gICAgICB0aGlzW1wic1wiXSAqIHRoaXNbXCJuXCJdICogUFtcImRcIl0gKyBQW1wic1wiXSAqIHRoaXNbXCJkXCJdICogUFtcIm5cIl0sXG4gICAgICB0aGlzW1wiZFwiXSAqIFBbXCJkXCJdXG4gICAgKTtcbiAgfSxcblxuICAvKipcbiAgICogU3VidHJhY3RzIHR3byByYXRpb25hbCBudW1iZXJzXG4gICAqXG4gICAqIEV4OiBuZXcgRnJhY3Rpb24oe246IDIsIGQ6IDN9KS5hZGQoXCIxNC45XCIpID0+IC00MjcgLyAzMFxuICAgKiovXG4gIFwic3ViXCI6IGZ1bmN0aW9uIChhLCBiKSB7XG5cbiAgICBwYXJzZShhLCBiKTtcbiAgICByZXR1cm4gbmV3RnJhY3Rpb24oXG4gICAgICB0aGlzW1wic1wiXSAqIHRoaXNbXCJuXCJdICogUFtcImRcIl0gLSBQW1wic1wiXSAqIHRoaXNbXCJkXCJdICogUFtcIm5cIl0sXG4gICAgICB0aGlzW1wiZFwiXSAqIFBbXCJkXCJdXG4gICAgKTtcbiAgfSxcblxuICAvKipcbiAgICogTXVsdGlwbGllcyB0d28gcmF0aW9uYWwgbnVtYmVyc1xuICAgKlxuICAgKiBFeDogbmV3IEZyYWN0aW9uKFwiLTE3LigzNDUpXCIpLm11bCgzKSA9PiA1Nzc2IC8gMTExXG4gICAqKi9cbiAgXCJtdWxcIjogZnVuY3Rpb24gKGEsIGIpIHtcblxuICAgIHBhcnNlKGEsIGIpO1xuICAgIHJldHVybiBuZXdGcmFjdGlvbihcbiAgICAgIHRoaXNbXCJzXCJdICogUFtcInNcIl0gKiB0aGlzW1wiblwiXSAqIFBbXCJuXCJdLFxuICAgICAgdGhpc1tcImRcIl0gKiBQW1wiZFwiXVxuICAgICk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERpdmlkZXMgdHdvIHJhdGlvbmFsIG51bWJlcnNcbiAgICpcbiAgICogRXg6IG5ldyBGcmFjdGlvbihcIi0xNy4oMzQ1KVwiKS5pbnZlcnNlKCkuZGl2KDMpXG4gICAqKi9cbiAgXCJkaXZcIjogZnVuY3Rpb24gKGEsIGIpIHtcblxuICAgIHBhcnNlKGEsIGIpO1xuICAgIHJldHVybiBuZXdGcmFjdGlvbihcbiAgICAgIHRoaXNbXCJzXCJdICogUFtcInNcIl0gKiB0aGlzW1wiblwiXSAqIFBbXCJkXCJdLFxuICAgICAgdGhpc1tcImRcIl0gKiBQW1wiblwiXVxuICAgICk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENsb25lcyB0aGUgYWN0dWFsIG9iamVjdFxuICAgKlxuICAgKiBFeDogbmV3IEZyYWN0aW9uKFwiLTE3LigzNDUpXCIpLmNsb25lKClcbiAgICoqL1xuICBcImNsb25lXCI6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3RnJhY3Rpb24odGhpc1sncyddICogdGhpc1snbiddLCB0aGlzWydkJ10pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBtb2R1bG8gb2YgdHdvIHJhdGlvbmFsIG51bWJlcnMgLSBhIG1vcmUgcHJlY2lzZSBmbW9kXG4gICAqXG4gICAqIEV4OiBuZXcgRnJhY3Rpb24oJzQuKDMpJykubW9kKFs3LCA4XSkgPT4gKDEzLzMpICUgKDcvOCkgPSAoNS82KVxuICAgKiBFeDogbmV3IEZyYWN0aW9uKDIwLCAxMCkubW9kKCkuZXF1YWxzKDApID8gXCJpcyBJbnRlZ2VyXCJcbiAgICoqL1xuICBcIm1vZFwiOiBmdW5jdGlvbiAoYSwgYikge1xuXG4gICAgaWYgKGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIG5ld0ZyYWN0aW9uKHRoaXNbXCJzXCJdICogdGhpc1tcIm5cIl0gJSB0aGlzW1wiZFwiXSwgQ19PTkUpO1xuICAgIH1cblxuICAgIHBhcnNlKGEsIGIpO1xuICAgIGlmIChDX1pFUk8gPT09IFBbXCJuXCJdICogdGhpc1tcImRcIl0pIHtcbiAgICAgIHRocm93IERpdmlzaW9uQnlaZXJvKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSSBkZXJpdmVkIHRoZSByYXRpb25hbCBtb2R1bG8gc2ltaWxhciB0byB0aGUgbW9kdWxvIGZvciBpbnRlZ2Vyc1xuICAgICAqXG4gICAgICogaHR0cHM6Ly9yYXcub3JnL2Jvb2svYW5hbHlzaXMvcmF0aW9uYWwtbnVtYmVycy9cbiAgICAgKlxuICAgICAqICAgIG4xL2QxID0gKG4yL2QyKSAqIHEgKyByLCB3aGVyZSAwIOKJpCByIDwgbjIvZDJcbiAgICAgKiA9PiBkMiAqIG4xID0gbjIgKiBkMSAqIHEgKyBkMSAqIGQyICogclxuICAgICAqID0+IHIgPSAoZDIgKiBuMSAtIG4yICogZDEgKiBxKSAvIChkMSAqIGQyKVxuICAgICAqICAgICAgPSAoZDIgKiBuMSAtIG4yICogZDEgKiBmbG9vcigoZDIgKiBuMSkgLyAobjIgKiBkMSkpKSAvIChkMSAqIGQyKVxuICAgICAqICAgICAgPSAoKGQyICogbjEpICUgKG4yICogZDEpKSAvIChkMSAqIGQyKVxuICAgICAqL1xuICAgIHJldHVybiBuZXdGcmFjdGlvbihcbiAgICAgIHRoaXNbXCJzXCJdICogKFBbXCJkXCJdICogdGhpc1tcIm5cIl0pICUgKFBbXCJuXCJdICogdGhpc1tcImRcIl0pLFxuICAgICAgUFtcImRcIl0gKiB0aGlzW1wiZFwiXSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIGZyYWN0aW9uYWwgZ2NkIG9mIHR3byByYXRpb25hbCBudW1iZXJzXG4gICAqXG4gICAqIEV4OiBuZXcgRnJhY3Rpb24oNSw4KS5nY2QoMyw3KSA9PiAxLzU2XG4gICAqL1xuICBcImdjZFwiOiBmdW5jdGlvbiAoYSwgYikge1xuXG4gICAgcGFyc2UoYSwgYik7XG5cbiAgICAvLyBodHRwczovL3Jhdy5vcmcvYm9vay9hbmFseXNpcy9yYXRpb25hbC1udW1iZXJzL1xuICAgIC8vIGdjZChhIC8gYiwgYyAvIGQpID0gZ2NkKGEsIGMpIC8gbGNtKGIsIGQpXG5cbiAgICByZXR1cm4gbmV3RnJhY3Rpb24oZ2NkKFBbXCJuXCJdLCB0aGlzW1wiblwiXSkgKiBnY2QoUFtcImRcIl0sIHRoaXNbXCJkXCJdKSwgUFtcImRcIl0gKiB0aGlzW1wiZFwiXSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIGZyYWN0aW9uYWwgbGNtIG9mIHR3byByYXRpb25hbCBudW1iZXJzXG4gICAqXG4gICAqIEV4OiBuZXcgRnJhY3Rpb24oNSw4KS5sY20oMyw3KSA9PiAxNVxuICAgKi9cbiAgXCJsY21cIjogZnVuY3Rpb24gKGEsIGIpIHtcblxuICAgIHBhcnNlKGEsIGIpO1xuXG4gICAgLy8gaHR0cHM6Ly9yYXcub3JnL2Jvb2svYW5hbHlzaXMvcmF0aW9uYWwtbnVtYmVycy9cbiAgICAvLyBsY20oYSAvIGIsIGMgLyBkKSA9IGxjbShhLCBjKSAvIGdjZChiLCBkKVxuXG4gICAgaWYgKFBbXCJuXCJdID09PSBDX1pFUk8gJiYgdGhpc1tcIm5cIl0gPT09IENfWkVSTykge1xuICAgICAgcmV0dXJuIG5ld0ZyYWN0aW9uKENfWkVSTywgQ19PTkUpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3RnJhY3Rpb24oUFtcIm5cIl0gKiB0aGlzW1wiblwiXSwgZ2NkKFBbXCJuXCJdLCB0aGlzW1wiblwiXSkgKiBnY2QoUFtcImRcIl0sIHRoaXNbXCJkXCJdKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGludmVyc2Ugb2YgdGhlIGZyYWN0aW9uLCBtZWFucyBudW1lcmF0b3IgYW5kIGRlbm9taW5hdG9yIGFyZSBleGNoYW5nZWRcbiAgICpcbiAgICogRXg6IG5ldyBGcmFjdGlvbihbLTMsIDRdKS5pbnZlcnNlKCkgPT4gLTQgLyAzXG4gICAqKi9cbiAgXCJpbnZlcnNlXCI6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3RnJhY3Rpb24odGhpc1tcInNcIl0gKiB0aGlzW1wiZFwiXSwgdGhpc1tcIm5cIl0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBmcmFjdGlvbiB0byBzb21lIGludGVnZXIgZXhwb25lbnRcbiAgICpcbiAgICogRXg6IG5ldyBGcmFjdGlvbigtMSwyKS5wb3coLTMpID0+IC04XG4gICAqL1xuICBcInBvd1wiOiBmdW5jdGlvbiAoYSwgYikge1xuXG4gICAgcGFyc2UoYSwgYik7XG5cbiAgICAvLyBUcml2aWFsIGNhc2Ugd2hlbiBleHAgaXMgYW4gaW50ZWdlclxuXG4gICAgaWYgKFBbJ2QnXSA9PT0gQ19PTkUpIHtcblxuICAgICAgaWYgKFBbJ3MnXSA8IENfWkVSTykge1xuICAgICAgICByZXR1cm4gbmV3RnJhY3Rpb24oKHRoaXNbJ3MnXSAqIHRoaXNbXCJkXCJdKSAqKiBQWyduJ10sIHRoaXNbXCJuXCJdICoqIFBbJ24nXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3RnJhY3Rpb24oKHRoaXNbJ3MnXSAqIHRoaXNbXCJuXCJdKSAqKiBQWyduJ10sIHRoaXNbXCJkXCJdICoqIFBbJ24nXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTmVnYXRpdmUgcm9vdHMgYmVjb21lIGNvbXBsZXhcbiAgICAvLyAgICAgKC1hL2IpXihjL2QpID0geFxuICAgIC8vIOKHlCAoLTEpXihjL2QpICogKGEvYileKGMvZCkgPSB4XG4gICAgLy8g4oeUIChjb3MocGkpICsgaSpzaW4ocGkpKV4oYy9kKSAqIChhL2IpXihjL2QpID0geFxuICAgIC8vIOKHlCAoY29zKGMqcGkvZCkgKyBpKnNpbihjKnBpL2QpKSAqIChhL2IpXihjL2QpID0geCAgICAgICAjIERlTW9pdnJlJ3MgZm9ybXVsYVxuICAgIC8vIEZyb20gd2hpY2ggZm9sbG93cyB0aGF0IG9ubHkgZm9yIGM9MCB0aGUgcm9vdCBpcyBub24tY29tcGxleFxuICAgIGlmICh0aGlzWydzJ10gPCBDX1pFUk8pIHJldHVybiBudWxsO1xuXG4gICAgLy8gTm93IHByaW1lIGZhY3RvciBuIGFuZCBkXG4gICAgbGV0IE4gPSBmYWN0b3JpemUodGhpc1snbiddKTtcbiAgICBsZXQgRCA9IGZhY3Rvcml6ZSh0aGlzWydkJ10pO1xuXG4gICAgLy8gRXhwb25lbnRpYXRlIGFuZCB0YWtlIHJvb3QgZm9yIG4gYW5kIGQgaW5kaXZpZHVhbGx5XG4gICAgbGV0IG4gPSBDX09ORTtcbiAgICBsZXQgZCA9IENfT05FO1xuICAgIGZvciAobGV0IGsgaW4gTikge1xuICAgICAgaWYgKGsgPT09ICcxJykgY29udGludWU7XG4gICAgICBpZiAoayA9PT0gJzAnKSB7XG4gICAgICAgIG4gPSBDX1pFUk87XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgTltrXSAqPSBQWyduJ107XG5cbiAgICAgIGlmIChOW2tdICUgUFsnZCddID09PSBDX1pFUk8pIHtcbiAgICAgICAgTltrXSAvPSBQWydkJ107XG4gICAgICB9IGVsc2UgcmV0dXJuIG51bGw7XG4gICAgICBuICo9IEJpZ0ludChrKSAqKiBOW2tdO1xuICAgIH1cblxuICAgIGZvciAobGV0IGsgaW4gRCkge1xuICAgICAgaWYgKGsgPT09ICcxJykgY29udGludWU7XG4gICAgICBEW2tdICo9IFBbJ24nXTtcblxuICAgICAgaWYgKERba10gJSBQWydkJ10gPT09IENfWkVSTykge1xuICAgICAgICBEW2tdIC89IFBbJ2QnXTtcbiAgICAgIH0gZWxzZSByZXR1cm4gbnVsbDtcbiAgICAgIGQgKj0gQmlnSW50KGspICoqIERba107XG4gICAgfVxuXG4gICAgaWYgKFBbJ3MnXSA8IENfWkVSTykge1xuICAgICAgcmV0dXJuIG5ld0ZyYWN0aW9uKGQsIG4pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3RnJhY3Rpb24obiwgZCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIGxvZ2FyaXRobSBvZiBhIGZyYWN0aW9uIHRvIGEgZ2l2ZW4gcmF0aW9uYWwgYmFzZVxuICAgKlxuICAgKiBFeDogbmV3IEZyYWN0aW9uKDI3LCA4KS5sb2coOSwgNCkgPT4gMy8yXG4gICAqL1xuICBcImxvZ1wiOiBmdW5jdGlvbiAoYSwgYikge1xuXG4gICAgcGFyc2UoYSwgYik7XG5cbiAgICBpZiAodGhpc1sncyddIDw9IENfWkVSTyB8fCBQWydzJ10gPD0gQ19aRVJPKSByZXR1cm4gbnVsbDtcblxuICAgIGNvbnN0IGFsbFByaW1lcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICBjb25zdCBiYXNlRmFjdG9ycyA9IGZhY3Rvcml6ZShQWyduJ10pO1xuICAgIGNvbnN0IFQxID0gZmFjdG9yaXplKFBbJ2QnXSk7XG5cbiAgICBjb25zdCBudW1iZXJGYWN0b3JzID0gZmFjdG9yaXplKHRoaXNbJ24nXSk7XG4gICAgY29uc3QgVDIgPSBmYWN0b3JpemUodGhpc1snZCddKTtcblxuICAgIGZvciAoY29uc3QgcHJpbWUgaW4gVDEpIHtcbiAgICAgIGJhc2VGYWN0b3JzW3ByaW1lXSA9IChiYXNlRmFjdG9yc1twcmltZV0gfHwgQ19aRVJPKSAtIFQxW3ByaW1lXTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBwcmltZSBpbiBUMikge1xuICAgICAgbnVtYmVyRmFjdG9yc1twcmltZV0gPSAobnVtYmVyRmFjdG9yc1twcmltZV0gfHwgQ19aRVJPKSAtIFQyW3ByaW1lXTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHByaW1lIGluIGJhc2VGYWN0b3JzKSB7XG4gICAgICBpZiAocHJpbWUgPT09ICcxJykgY29udGludWU7XG4gICAgICBhbGxQcmltZXNbcHJpbWVdID0gdHJ1ZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBwcmltZSBpbiBudW1iZXJGYWN0b3JzKSB7XG4gICAgICBpZiAocHJpbWUgPT09ICcxJykgY29udGludWU7XG4gICAgICBhbGxQcmltZXNbcHJpbWVdID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBsZXQgcmV0TiA9IG51bGw7XG4gICAgbGV0IHJldEQgPSBudWxsO1xuXG4gICAgLy8gSXRlcmF0ZSBvdmVyIGFsbCB1bmlxdWUgcHJpbWVzIHRvIGRldGVybWluZSBpZiBhIGNvbnNpc3RlbnQgcmF0aW8gZXhpc3RzXG4gICAgZm9yIChjb25zdCBwcmltZSBpbiBhbGxQcmltZXMpIHtcblxuICAgICAgY29uc3QgYmFzZUV4cG9uZW50ID0gYmFzZUZhY3RvcnNbcHJpbWVdIHx8IENfWkVSTztcbiAgICAgIGNvbnN0IG51bWJlckV4cG9uZW50ID0gbnVtYmVyRmFjdG9yc1twcmltZV0gfHwgQ19aRVJPO1xuXG4gICAgICBpZiAoYmFzZUV4cG9uZW50ID09PSBDX1pFUk8pIHtcbiAgICAgICAgaWYgKG51bWJlckV4cG9uZW50ICE9PSBDX1pFUk8pIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gTG9nYXJpdGhtIGNhbm5vdCBiZSBleHByZXNzZWQgYXMgYSByYXRpb25hbCBudW1iZXJcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTsgLy8gU2tpcCB0aGlzIHByaW1lIHNpbmNlIGJvdGggZXhwb25lbnRzIGFyZSB6ZXJvXG4gICAgICB9XG5cbiAgICAgIC8vIENhbGN1bGF0ZSB0aGUgcmF0aW8gb2YgZXhwb25lbnRzIGZvciB0aGlzIHByaW1lXG4gICAgICBsZXQgY3VyTiA9IG51bWJlckV4cG9uZW50O1xuICAgICAgbGV0IGN1ckQgPSBiYXNlRXhwb25lbnQ7XG5cbiAgICAgIC8vIFNpbXBsaWZ5IHRoZSBjdXJyZW50IHJhdGlvXG4gICAgICBjb25zdCBnY2RWYWx1ZSA9IGdjZChjdXJOLCBjdXJEKTtcbiAgICAgIGN1ck4gLz0gZ2NkVmFsdWU7XG4gICAgICBjdXJEIC89IGdjZFZhbHVlO1xuXG4gICAgICAvLyBDaGVjayBpZiB0aGlzIGlzIHRoZSBmaXJzdCByYXRpbzsgb3RoZXJ3aXNlLCBlbnN1cmUgcmF0aW9zIGFyZSBjb25zaXN0ZW50XG4gICAgICBpZiAocmV0TiA9PT0gbnVsbCAmJiByZXREID09PSBudWxsKSB7XG4gICAgICAgIHJldE4gPSBjdXJOO1xuICAgICAgICByZXREID0gY3VyRDtcbiAgICAgIH0gZWxzZSBpZiAoY3VyTiAqIHJldEQgIT09IHJldE4gKiBjdXJEKSB7XG4gICAgICAgIHJldHVybiBudWxsOyAvLyBSYXRpb3MgZG8gbm90IG1hdGNoLCBsb2dhcml0aG0gY2Fubm90IGJlIHJhdGlvbmFsXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldE4gIT09IG51bGwgJiYgcmV0RCAhPT0gbnVsbFxuICAgICAgPyBuZXdGcmFjdGlvbihyZXROLCByZXREKVxuICAgICAgOiBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0d28gcmF0aW9uYWwgbnVtYmVycyBhcmUgdGhlIHNhbWVcbiAgICpcbiAgICogRXg6IG5ldyBGcmFjdGlvbigxOS42KS5lcXVhbHMoWzk4LCA1XSk7XG4gICAqKi9cbiAgXCJlcXVhbHNcIjogZnVuY3Rpb24gKGEsIGIpIHtcblxuICAgIHBhcnNlKGEsIGIpO1xuICAgIHJldHVybiB0aGlzW1wic1wiXSAqIHRoaXNbXCJuXCJdICogUFtcImRcIl0gPT09IFBbXCJzXCJdICogUFtcIm5cIl0gKiB0aGlzW1wiZFwiXTtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhpcyByYXRpb25hbCBudW1iZXIgaXMgbGVzcyB0aGFuIGFub3RoZXJcbiAgICpcbiAgICogRXg6IG5ldyBGcmFjdGlvbigxOS42KS5sdChbOTgsIDVdKTtcbiAgICoqL1xuICBcImx0XCI6IGZ1bmN0aW9uIChhLCBiKSB7XG5cbiAgICBwYXJzZShhLCBiKTtcbiAgICByZXR1cm4gdGhpc1tcInNcIl0gKiB0aGlzW1wiblwiXSAqIFBbXCJkXCJdIDwgUFtcInNcIl0gKiBQW1wiblwiXSAqIHRoaXNbXCJkXCJdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGlzIHJhdGlvbmFsIG51bWJlciBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgYW5vdGhlclxuICAgKlxuICAgKiBFeDogbmV3IEZyYWN0aW9uKDE5LjYpLmx0KFs5OCwgNV0pO1xuICAgKiovXG4gIFwibHRlXCI6IGZ1bmN0aW9uIChhLCBiKSB7XG5cbiAgICBwYXJzZShhLCBiKTtcbiAgICByZXR1cm4gdGhpc1tcInNcIl0gKiB0aGlzW1wiblwiXSAqIFBbXCJkXCJdIDw9IFBbXCJzXCJdICogUFtcIm5cIl0gKiB0aGlzW1wiZFwiXTtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhpcyByYXRpb25hbCBudW1iZXIgaXMgZ3JlYXRlciB0aGFuIGFub3RoZXJcbiAgICpcbiAgICogRXg6IG5ldyBGcmFjdGlvbigxOS42KS5sdChbOTgsIDVdKTtcbiAgICoqL1xuICBcImd0XCI6IGZ1bmN0aW9uIChhLCBiKSB7XG5cbiAgICBwYXJzZShhLCBiKTtcbiAgICByZXR1cm4gdGhpc1tcInNcIl0gKiB0aGlzW1wiblwiXSAqIFBbXCJkXCJdID4gUFtcInNcIl0gKiBQW1wiblwiXSAqIHRoaXNbXCJkXCJdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGlzIHJhdGlvbmFsIG51bWJlciBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgYW5vdGhlclxuICAgKlxuICAgKiBFeDogbmV3IEZyYWN0aW9uKDE5LjYpLmx0KFs5OCwgNV0pO1xuICAgKiovXG4gIFwiZ3RlXCI6IGZ1bmN0aW9uIChhLCBiKSB7XG5cbiAgICBwYXJzZShhLCBiKTtcbiAgICByZXR1cm4gdGhpc1tcInNcIl0gKiB0aGlzW1wiblwiXSAqIFBbXCJkXCJdID49IFBbXCJzXCJdICogUFtcIm5cIl0gKiB0aGlzW1wiZFwiXTtcbiAgfSxcblxuICAvKipcbiAgICogQ29tcGFyZSB0d28gcmF0aW9uYWwgbnVtYmVyc1xuICAgKiA8IDAgaWZmIHRoaXMgPCB0aGF0XG4gICAqID4gMCBpZmYgdGhpcyA+IHRoYXRcbiAgICogPSAwIGlmZiB0aGlzID0gdGhhdFxuICAgKlxuICAgKiBFeDogbmV3IEZyYWN0aW9uKDE5LjYpLmNvbXBhcmUoWzk4LCA1XSk7XG4gICAqKi9cbiAgXCJjb21wYXJlXCI6IGZ1bmN0aW9uIChhLCBiKSB7XG5cbiAgICBwYXJzZShhLCBiKTtcbiAgICBsZXQgdCA9IHRoaXNbXCJzXCJdICogdGhpc1tcIm5cIl0gKiBQW1wiZFwiXSAtIFBbXCJzXCJdICogUFtcIm5cIl0gKiB0aGlzW1wiZFwiXTtcblxuICAgIHJldHVybiAoQ19aRVJPIDwgdCkgLSAodCA8IENfWkVSTyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIGNlaWwgb2YgYSByYXRpb25hbCBudW1iZXJcbiAgICpcbiAgICogRXg6IG5ldyBGcmFjdGlvbignNC4oMyknKS5jZWlsKCkgPT4gKDUgLyAxKVxuICAgKiovXG4gIFwiY2VpbFwiOiBmdW5jdGlvbiAocGxhY2VzKSB7XG5cbiAgICBwbGFjZXMgPSBDX1RFTiAqKiBCaWdJbnQocGxhY2VzIHx8IDApO1xuXG4gICAgcmV0dXJuIG5ld0ZyYWN0aW9uKGlmbG9vcih0aGlzW1wic1wiXSAqIHBsYWNlcyAqIHRoaXNbXCJuXCJdIC8gdGhpc1tcImRcIl0pICtcbiAgICAgIChwbGFjZXMgKiB0aGlzW1wiblwiXSAlIHRoaXNbXCJkXCJdID4gQ19aRVJPICYmIHRoaXNbXCJzXCJdID49IENfWkVSTyA/IENfT05FIDogQ19aRVJPKSxcbiAgICAgIHBsYWNlcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIGZsb29yIG9mIGEgcmF0aW9uYWwgbnVtYmVyXG4gICAqXG4gICAqIEV4OiBuZXcgRnJhY3Rpb24oJzQuKDMpJykuZmxvb3IoKSA9PiAoNCAvIDEpXG4gICAqKi9cbiAgXCJmbG9vclwiOiBmdW5jdGlvbiAocGxhY2VzKSB7XG5cbiAgICBwbGFjZXMgPSBDX1RFTiAqKiBCaWdJbnQocGxhY2VzIHx8IDApO1xuXG4gICAgcmV0dXJuIG5ld0ZyYWN0aW9uKGlmbG9vcih0aGlzW1wic1wiXSAqIHBsYWNlcyAqIHRoaXNbXCJuXCJdIC8gdGhpc1tcImRcIl0pIC1cbiAgICAgIChwbGFjZXMgKiB0aGlzW1wiblwiXSAlIHRoaXNbXCJkXCJdID4gQ19aRVJPICYmIHRoaXNbXCJzXCJdIDwgQ19aRVJPID8gQ19PTkUgOiBDX1pFUk8pLFxuICAgICAgcGxhY2VzKTtcbiAgfSxcblxuICAvKipcbiAgICogUm91bmRzIGEgcmF0aW9uYWwgbnVtYmVyc1xuICAgKlxuICAgKiBFeDogbmV3IEZyYWN0aW9uKCc0LigzKScpLnJvdW5kKCkgPT4gKDQgLyAxKVxuICAgKiovXG4gIFwicm91bmRcIjogZnVuY3Rpb24gKHBsYWNlcykge1xuXG4gICAgcGxhY2VzID0gQ19URU4gKiogQmlnSW50KHBsYWNlcyB8fCAwKTtcblxuICAgIC8qIERlcml2YXRpb246XG5cbiAgICBzID49IDA6XG4gICAgICByb3VuZChuIC8gZCkgPSBpZmxvb3IobiAvIGQpICsgKG4gJSBkKSAvIGQgPj0gMC41ID8gMSA6IDBcbiAgICAgICAgICAgICAgICAgICA9IGlmbG9vcihuIC8gZCkgKyAyKG4gJSBkKSA+PSBkID8gMSA6IDBcbiAgICBzIDwgMDpcbiAgICAgIHJvdW5kKG4gLyBkKSA9LWlmbG9vcihuIC8gZCkgLSAobiAlIGQpIC8gZCA+IDAuNSA/IDEgOiAwXG4gICAgICAgICAgICAgICAgICAgPS1pZmxvb3IobiAvIGQpIC0gMihuICUgZCkgPiBkID8gMSA6IDBcblxuICAgID0+OlxuXG4gICAgcm91bmQocyAqIG4gLyBkKSA9IHMgKiBpZmxvb3IobiAvIGQpICsgcyAqIChDICsgMihuICUgZCkgPiBkID8gMSA6IDApXG4gICAgICAgIHdoZXJlIEMgPSBzID49IDAgPyAxIDogMCwgdG8gZml4IHRoZSA+PSBmb3IgdGhlIHBvc2l0dmUgY2FzZS5cbiAgICAqL1xuXG4gICAgcmV0dXJuIG5ld0ZyYWN0aW9uKGlmbG9vcih0aGlzW1wic1wiXSAqIHBsYWNlcyAqIHRoaXNbXCJuXCJdIC8gdGhpc1tcImRcIl0pICtcbiAgICAgIHRoaXNbXCJzXCJdICogKCh0aGlzW1wic1wiXSA+PSBDX1pFUk8gPyBDX09ORSA6IENfWkVSTykgKyBDX1RXTyAqIChwbGFjZXMgKiB0aGlzW1wiblwiXSAlIHRoaXNbXCJkXCJdKSA+IHRoaXNbXCJkXCJdID8gQ19PTkUgOiBDX1pFUk8pLFxuICAgICAgcGxhY2VzKTtcbiAgfSxcblxuICAvKipcbiAgICAqIFJvdW5kcyBhIHJhdGlvbmFsIG51bWJlciB0byBhIG11bHRpcGxlIG9mIGFub3RoZXIgcmF0aW9uYWwgbnVtYmVyXG4gICAgKlxuICAgICogRXg6IG5ldyBGcmFjdGlvbignMC45Jykucm91bmRUbyhcIjEvOFwiKSA9PiA3IC8gOFxuICAgICoqL1xuICBcInJvdW5kVG9cIjogZnVuY3Rpb24gKGEsIGIpIHtcblxuICAgIC8qXG4gICAgayAqIHgveSDiiaQgYS9iIDwgKGsrMSkgKiB4L3lcbiAgICDih5QgayDiiaQgYS9iIC8gKHgveSkgPCAoaysxKVxuICAgIOKHlCBrID0gZmxvb3IoYS9iICogeS94KVxuICAgIOKHlCBrID0gZmxvb3IoKGEgKiB5KSAvIChiICogeCkpXG4gICAgKi9cblxuICAgIHBhcnNlKGEsIGIpO1xuXG4gICAgY29uc3QgbiA9IHRoaXNbJ24nXSAqIFBbJ2QnXTtcbiAgICBjb25zdCBkID0gdGhpc1snZCddICogUFsnbiddO1xuICAgIGNvbnN0IHIgPSBuICUgZDtcblxuICAgIC8vIHJvdW5kKG4gLyBkKSA9IGlmbG9vcihuIC8gZCkgKyAyKG4gJSBkKSA+PSBkID8gMSA6IDBcbiAgICBsZXQgayA9IGlmbG9vcihuIC8gZCk7XG4gICAgaWYgKHIgKyByID49IGQpIHtcbiAgICAgIGsrKztcbiAgICB9XG4gICAgcmV0dXJuIG5ld0ZyYWN0aW9uKHRoaXNbJ3MnXSAqIGsgKiBQWyduJ10sIFBbJ2QnXSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHR3byByYXRpb25hbCBudW1iZXJzIGFyZSBkaXZpc2libGVcbiAgICpcbiAgICogRXg6IG5ldyBGcmFjdGlvbigxOS42KS5kaXZpc2libGUoMS41KTtcbiAgICovXG4gIFwiZGl2aXNpYmxlXCI6IGZ1bmN0aW9uIChhLCBiKSB7XG5cbiAgICBwYXJzZShhLCBiKTtcbiAgICBpZiAoUFsnbiddID09PSBDX1pFUk8pIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gKHRoaXNbJ24nXSAqIFBbJ2QnXSkgJSAoUFsnbiddICogdGhpc1snZCddKSA9PT0gQ19aRVJPO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgZGVjaW1hbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZnJhY3Rpb25cbiAgICpcbiAgICogRXg6IG5ldyBGcmFjdGlvbihcIjEwMC4nOTE4MjMnXCIpLnZhbHVlT2YoKSA9PiAxMDAuOTE4MjM5MTgyMzkxODNcbiAgICoqL1xuICAndmFsdWVPZic6IGZ1bmN0aW9uICgpIHtcbiAgICAvL2lmICh0aGlzWyduJ10gPD0gTUFYX0lOVEVHRVIgJiYgdGhpc1snZCddIDw9IE1BWF9JTlRFR0VSKSB7XG4gICAgcmV0dXJuIE51bWJlcih0aGlzWydzJ10gKiB0aGlzWyduJ10pIC8gTnVtYmVyKHRoaXNbJ2QnXSk7XG4gICAgLy99XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBmcmFjdGlvbiB3aXRoIGFsbCBkaWdpdHNcbiAgICpcbiAgICogRXg6IG5ldyBGcmFjdGlvbihcIjEwMC4nOTE4MjMnXCIpLnRvU3RyaW5nKCkgPT4gXCIxMDAuKDkxODIzKVwiXG4gICAqKi9cbiAgJ3RvU3RyaW5nJzogZnVuY3Rpb24gKGRlYyA9IDE1KSB7XG5cbiAgICBsZXQgTiA9IHRoaXNbXCJuXCJdO1xuICAgIGxldCBEID0gdGhpc1tcImRcIl07XG5cbiAgICBsZXQgY3ljTGVuID0gY3ljbGVMZW4oTiwgRCk7IC8vIEN5Y2xlIGxlbmd0aFxuICAgIGxldCBjeWNPZmYgPSBjeWNsZVN0YXJ0KE4sIEQsIGN5Y0xlbik7IC8vIEN5Y2xlIHN0YXJ0XG5cbiAgICBsZXQgc3RyID0gdGhpc1sncyddIDwgQ19aRVJPID8gXCItXCIgOiBcIlwiO1xuXG4gICAgLy8gQXBwZW5kIGludGVnZXIgcGFydFxuICAgIHN0ciArPSBpZmxvb3IoTiAvIEQpO1xuXG4gICAgTiAlPSBEO1xuICAgIE4gKj0gQ19URU47XG5cbiAgICBpZiAoTilcbiAgICAgIHN0ciArPSBcIi5cIjtcblxuICAgIGlmIChjeWNMZW4pIHtcblxuICAgICAgZm9yIChsZXQgaSA9IGN5Y09mZjsgaS0tOykge1xuICAgICAgICBzdHIgKz0gaWZsb29yKE4gLyBEKTtcbiAgICAgICAgTiAlPSBEO1xuICAgICAgICBOICo9IENfVEVOO1xuICAgICAgfVxuICAgICAgc3RyICs9IFwiKFwiO1xuICAgICAgZm9yIChsZXQgaSA9IGN5Y0xlbjsgaS0tOykge1xuICAgICAgICBzdHIgKz0gaWZsb29yKE4gLyBEKTtcbiAgICAgICAgTiAlPSBEO1xuICAgICAgICBOICo9IENfVEVOO1xuICAgICAgfVxuICAgICAgc3RyICs9IFwiKVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBpID0gZGVjOyBOICYmIGktLTspIHtcbiAgICAgICAgc3RyICs9IGlmbG9vcihOIC8gRCk7XG4gICAgICAgIE4gJT0gRDtcbiAgICAgICAgTiAqPSBDX1RFTjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZy1mcmFjdGlvbiByZXByZXNlbnRhdGlvbiBvZiBhIEZyYWN0aW9uIG9iamVjdFxuICAgKlxuICAgKiBFeDogbmV3IEZyYWN0aW9uKFwiMS4nMydcIikudG9GcmFjdGlvbigpID0+IFwiNCAxLzNcIlxuICAgKiovXG4gICd0b0ZyYWN0aW9uJzogZnVuY3Rpb24gKHNob3dNaXhlZCA9IGZhbHNlKSB7XG5cbiAgICBsZXQgbiA9IHRoaXNbXCJuXCJdO1xuICAgIGxldCBkID0gdGhpc1tcImRcIl07XG4gICAgbGV0IHN0ciA9IHRoaXNbJ3MnXSA8IENfWkVSTyA/IFwiLVwiIDogXCJcIjtcblxuICAgIGlmIChkID09PSBDX09ORSkge1xuICAgICAgc3RyICs9IG47XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHdob2xlID0gaWZsb29yKG4gLyBkKTtcbiAgICAgIGlmIChzaG93TWl4ZWQgJiYgd2hvbGUgPiBDX1pFUk8pIHtcbiAgICAgICAgc3RyICs9IHdob2xlO1xuICAgICAgICBzdHIgKz0gXCIgXCI7XG4gICAgICAgIG4gJT0gZDtcbiAgICAgIH1cblxuICAgICAgc3RyICs9IG47XG4gICAgICBzdHIgKz0gJy8nO1xuICAgICAgc3RyICs9IGQ7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsYXRleCByZXByZXNlbnRhdGlvbiBvZiBhIEZyYWN0aW9uIG9iamVjdFxuICAgKlxuICAgKiBFeDogbmV3IEZyYWN0aW9uKFwiMS4nMydcIikudG9MYXRleCgpID0+IFwiXFxmcmFjezR9ezN9XCJcbiAgICoqL1xuICAndG9MYXRleCc6IGZ1bmN0aW9uIChzaG93TWl4ZWQgPSBmYWxzZSkge1xuXG4gICAgbGV0IG4gPSB0aGlzW1wiblwiXTtcbiAgICBsZXQgZCA9IHRoaXNbXCJkXCJdO1xuICAgIGxldCBzdHIgPSB0aGlzWydzJ10gPCBDX1pFUk8gPyBcIi1cIiA6IFwiXCI7XG5cbiAgICBpZiAoZCA9PT0gQ19PTkUpIHtcbiAgICAgIHN0ciArPSBuO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB3aG9sZSA9IGlmbG9vcihuIC8gZCk7XG4gICAgICBpZiAoc2hvd01peGVkICYmIHdob2xlID4gQ19aRVJPKSB7XG4gICAgICAgIHN0ciArPSB3aG9sZTtcbiAgICAgICAgbiAlPSBkO1xuICAgICAgfVxuXG4gICAgICBzdHIgKz0gXCJcXFxcZnJhY3tcIjtcbiAgICAgIHN0ciArPSBuO1xuICAgICAgc3RyICs9ICd9eyc7XG4gICAgICBzdHIgKz0gZDtcbiAgICAgIHN0ciArPSAnfSc7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgb2YgY29udGludWVkIGZyYWN0aW9uIGVsZW1lbnRzXG4gICAqXG4gICAqIEV4OiBuZXcgRnJhY3Rpb24oXCI3LzhcIikudG9Db250aW51ZWQoKSA9PiBbMCwxLDddXG4gICAqL1xuICAndG9Db250aW51ZWQnOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBsZXQgYSA9IHRoaXNbJ24nXTtcbiAgICBsZXQgYiA9IHRoaXNbJ2QnXTtcbiAgICBjb25zdCByZXMgPSBbXTtcblxuICAgIHdoaWxlIChiKSB7XG4gICAgICByZXMucHVzaChpZmxvb3IoYSAvIGIpKTtcbiAgICAgIGNvbnN0IHQgPSBhICUgYjtcbiAgICAgIGEgPSBiO1xuICAgICAgYiA9IHQ7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH0sXG5cbiAgXCJzaW1wbGlmeVwiOiBmdW5jdGlvbiAoZXBzID0gMWUtMykge1xuXG4gICAgLy8gQ29udGludWVkIGZyYWN0aW9ucyBnaXZlIGJlc3QgYXBwcm94aW1hdGlvbnMgZm9yIGEgbWF4IGRlbm9taW5hdG9yLFxuICAgIC8vIGdlbmVyYWxseSBvdXRwZXJmb3JtaW5nIG1lZGlhbnRzIGluIGRlbm9taW5hdG9y4oCTYWNjdXJhY3kgdHJhZGUtb2Zmcy5cbiAgICAvLyBTZW1pY29udmVyZ2VudHMgY2FuIGZ1cnRoZXIgcmVkdWNlIHRoZSBkZW5vbWluYXRvciB3aXRoaW4gdG9sZXJhbmNlLlxuXG4gICAgY29uc3QgaWVwcyA9IEJpZ0ludChNYXRoLmNlaWwoMSAvIGVwcykpO1xuXG4gICAgY29uc3QgdGhpc0FCUyA9IHRoaXNbJ2FicyddKCk7XG4gICAgY29uc3QgY29udCA9IHRoaXNBQlNbJ3RvQ29udGludWVkJ10oKTtcblxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgY29udC5sZW5ndGg7IGkrKykge1xuXG4gICAgICBsZXQgcyA9IG5ld0ZyYWN0aW9uKGNvbnRbaSAtIDFdLCBDX09ORSk7XG4gICAgICBmb3IgKGxldCBrID0gaSAtIDI7IGsgPj0gMDsgay0tKSB7XG4gICAgICAgIHMgPSBzWydpbnZlcnNlJ10oKVsnYWRkJ10oY29udFtrXSk7XG4gICAgICB9XG5cbiAgICAgIGxldCB0ID0gc1snc3ViJ10odGhpc0FCUyk7XG4gICAgICBpZiAodFsnbiddICogaWVwcyA8IHRbJ2QnXSkgeyAvLyBNb3JlIHJvYnVzdCB0aGFuIE1hdGguYWJzKHQudmFsdWVPZigpKSA8IGVwc1xuICAgICAgICByZXR1cm4gc1snbXVsJ10odGhpc1sncyddKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG5leHBvcnQge1xuICBGcmFjdGlvbiBhcyBkZWZhdWx0LCBGcmFjdGlvblxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/fraction.js/dist/fraction.mjs\n");

/***/ })

};
;